[{"title":"《深入浅出Node.js》-5内存控制","url":"/2024/03/10/Nodejs/5/","content":"#### 1、V8的垃圾回收机制与内存限制\n> v8内存限制大小，为什么限制、垃圾回收机制、以及如何查看垃圾回收日志\n- 1、Node与v8\n  - Lars Bak 开发高性能的虚拟机工作背景\n  - 无与伦比的经历让V8一出世就超越了当时所有的JavaScript虚拟机。\n- 2、v8的内存限制\n  - 64位系统下约为1.4GB，32位系统下约为0.7 GB\n  - V8为何限制了内存的用量？\n  - 内存使用量的查看方式\n    ```bash\n    node\n    > process.memoryUsage();\n    { rss: 14958592,\n    heapTotal: 7195904,// v8申请到堆内存\n    heapUsed: 2821496 }// 当前使用量\n    ```\n  - 表层原因：为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。\n  - 深层原因：\n    - 是V8的垃圾回收机制的限制。\n    - 内存越大垃圾回收时间越多\n    - V8做一次小的垃圾回收需要50毫秒以上， \n    - 做一次非增量式的垃圾回收甚至要1秒以上\n    - 在当时的考虑下直接限制堆内存是一个好的选择。\n    - 使用更多内存\n      ```js\n      node --max-old-space-size=1700 test.js // 单位为MB（老生代）\n      // 或者\n      node --max-new-space-size=1024 test.js // 单位为KB（新生代）\n      ```\n  - 我曾在自己的项目中遇到过，服务器内存过小，导致vite启动打包失败\n- 3、V8的垃圾回收机制\n  - v8内存分代\n    - 新生代\n      - 存活时间较短的对象\n      - 两个reserved_semispace_size_所构成\n    - 老生代\n      - 较长、常驻\n  - v8的垃圾回收算法\n    - Scavenge算法（新生代、时间少）\n      - 采用 Cheney算法\n      - 内存一分为二， 每一部分空间称为semispace，\n      - 只有一个处于使用中（From空间）， 另一个处于闲置状态（To空间） \n      - 垃圾回收时， 会检查From中的存活对象，并且被被复制到To中，非存活对象占用的空间将会被释放。 \n      - 完成复制后， From空间和To空间的角色发生对换。（翻转）\n      - 当一个对象经过多次复制依然存活时，生命周期较长，随后会被移动到老生代中（晋升）\n      - 晋升两个条件：对象是否经历过Scavenge回收， 一个是To空间的内存占用比超过限制（超过25%）\n    - Mark-Sweep & Mark-Compact\n      - Mark-Sweep 标记清除\n        - 标记活着对象和清除没有被标记的对象\n        - 问题：内存碎片、不连续状态、不好分配大对象\n      - Mark-Compact 标记整理\n        - 解决sweep问题\n        - 对象在标记为死亡后，\n        - 在整理的过程中，将活着的对象往一端移动，移动完成后，\n        - 直接清理掉边界外的内存。\n      - v8中两种方法结合使用\n    - Incremental Marking 增量标记\n      - 以上三种算法执行时，应用逻辑暂停，为“全停顿”（stop-the-world） \n      - 老生代影响较大\n      - 解决：一口气停顿完成的动作，拆分为小“步进”\n      - 做一“步进”停下，就让应用逻辑执行，交替执行\n    - 延迟清理（lazy sweeping） 与增量式整理（incremental compaction）\n- 4、查看垃圾回收日志\n  - --trace_gc 看耗时\n    - node --trace_gc -e \"var a = [];for (var i = 0; i < 1000000; i++) a.push(new Array(100))\"\n    - 找出垃圾回收的哪些阶段比较`耗时`\n  - --prof\n    -  node --prof test01.js（5.1.js） //放一个1000000的for循环\n    -  得到一个v8.log日志文件，不具备可读性\n    -  linux-tick-processor v8.log\n    -  windows-tick-processor.bat v8.log\n       ```js\n       // 垃圾回收所占的时间为5.4%\n       [GC]:\n       ticks total nonlib name\n       2     5.4%\n       ```\n\n#### 2、高性能使用内存\n> 了解作用域、闭包以更好的使用内存\n- 1、作用域 scope\n- 2、闭包\n```js\n// 一旦有变量引用这个中间函数， 这个中间函数将不会释放， 同时也会使原始的作用域不会得到释放， \nvar foo = function () {\n  var bar = function () {\n    var local = \"局部变量\";\n    return function () {\n        return local;\n    };\n  };\n  var baz = bar();\n  console.log(baz());\n};\n```\n\n#### 3、内存指标\n> 进程内存（v8堆内存）以及如何查看、堆外内存\n1、查看内存使用\n  - 查看进程内存\n    - process.memoryUsage()(5.3.1.js)\n    - rss是resident set size的缩写， 即进程的常驻内存部分\n    - heapTotal 1367.99 MB heapUsed 1361.86 MB rss 1375.00 MB\n  - 查看系统内存\n    - os模块中的totalmem()和freemem()\n    ```js\n    node\n    > os.totalmem()\n    8589934592\n    > os.freemem()\n    4527833088\n    >\n    ```\n2、堆外内存（5.3.2.js）\n  - 使用buffer做测试案例\n  - Process: heapTotal 5.85 MB heapUsed 1.85 MB rss 3012.91 MB\n  - heapTotal与heapUsed的变化极小，唯一变化的是rss的值\n  - Buffer对象,它不经过V8的内存分配机制，不会有堆内存的大小限制。\n\n#### 4、内存泄漏\n> 内存泄漏会出现在哪些方面：缓存、队列、作用域，以及解决方案\n- 缓存\n- 队列消费不及时\n- 作用域未释放\n\n- 1、慎将内存当做缓存\n  - 常用对象的键值对来缓存东西\n  - 加上完善的过期策略以防止内存无限制增长，可以使用\n  - 1. 缓存限制策略，\n    - 加一种策略限制无限增长，limitablemap一旦超出就先进先出淘汰\n    - 模块机制中，模块编译后都会缓存，写模块时避免对象/数组无限制增长，添加清空队列的相应接口\n  - 2. 缓存解决方案\n    - 将缓存转移到外部：Redis、Memcached\n    - 进程之间可以共享缓存。\n- 2、关注队列状态（数组）\n  - 日志收集\n    - 表层解决方案：是换用消费速度更高的技术，换数据库为文件写入\n    - 深度：监控队列长度，一旦堆积、报警；任意异步调用包含超时机制\n\n#### 5、内存泄漏排查\n> 内存泄漏排查工具，如何使用\n- node-heapdump\n- node-memwatch\n- 模块较久更新，现在应该有更新的排查工具\n\n#### 6、大内存应用\n> 如何处理大文件：stream pipe\n- stream模块处理大文件(5.6.js)\n- fs的createReadStream()和createWriteStream()\n- 管道方法pipe()\n- 现在有功能更丰富的api，查阅node对应文档","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-4异步编程","url":"/2024/03/09/Nodejs/4/","content":"#### 1、函数式编程\n> 函数式编程的相关概念\n- 函数一等公民 -> Scheme语言 -> Lisp的派生\n- 高阶函数\n  - 高阶函数则是可以把函数作为参数， 或是将函数作为返回值的函数\n  ```js\n  function foo(x) {\n    return function () {\n      return x;\n    };\n  }\n  ```\n  - 后续传递风格（Continuation Passing Style）\n    - 它的结果接收方式，将函数的业务重点从返回值转移到了回调函数中\n    ```js\n    function foo(x, bar) {\n        return bar(x);\n    }\n    ```\n    - 经典的例子便是数组的sort()方法,以及forEach等等\n  - 偏函数\n    - 创建一个调用另外一个部分（参数或变量已经预置的函数）的函数的用法\n    ```js\n    var isType = function (type) {\n      return function (obj) {\n        return toString.call(obj) == '[object ' + type + ']';\n      };\n    };\n    var isString = isType('String');\n    var isFunction = isType('Function');\n    ```\n    - 指定部分参数来产生一个新的定制函数的形式就是偏函数\n\n#### 2、异步编程优势和难点\n- 优势：之前多篇已复述\n- 难点：\n  - 异常处理\n  - 函数嵌套过深\n  - 阻塞代码 - sleep()\n  - 多线程编程（第9章重点叙述）\n  - 异步转同步\n\n#### 3、异步编程解决方案\n> 通过一下集中思路\n> \n> 事件发布、订阅模式；（代码演示）\n> promise/deferred；（原理分析，与事件比较）\n> 流程控制库（用法和源码分析）\n> \n> 来解决异步\n> \n> 现在来看技术都已经比较过时，es6+后续版本的支持，\n> async await语法糖、Generator 协程（coroutine）已经很好的解决了异步编程的难点，\n> \n> 但是分析这些模块的实现原理，对于模块、思路、代码的演变很有帮助\n\n- 1、事件发布/订阅模式\n  - 事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。\n  - Node自身提供的events模块\n  - 它具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的事件监听模式的方法实现。\n  - 解耦业务逻辑， 事件发布者无须关注订阅的侦听器如何实现业务逻辑，甚至不用关注有多少个侦听器存在，数据通过消息的方式可以很灵活地传递\n  - 也是一种钩子（hook） 机制， 利用钩子导出内部数据或状态给外部的调用者\n  - 如果对一个事件添加了超过10个侦听器， 将会得到一条警告\n  - 为了处理异常， EventEmitter对象对error事件进行了特殊对待。 \n  - 1. 继承events模块\n  - 2. 利用事件队列解决雪崩问题\n  - 3. 多异步之间的协作方案，解决函数嵌套过深\n  - 接下来分析了EventProxy如何使用这种模式\n  - 4. EventProxy的原理\n  - 5. EventProxy的异常处理\n- 2、Promise/Deferred模式\n  - 使用事件的不足， 执行流程需要被预先设定\n  - Promise/Deferred模式最早出现于Dojo的代码中\n  - 广为所知则来自于jQuery 1.5版本\n  - 1. Promises/A\n    - 这里看到then()方法所做的事情是将回调函数存放起来。 \n    - 为了完成整个流程， 还需要触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred， 即延迟对象\n    - 与事件发布/订阅模式相比， Promise/Deferred模式的API接口和抽象模型都十分简洁。 \n    - 将业务中不可变的部分封装在了Deferred中， 将可变的部分交给了Promise\n    - Promise是高级接口， 事件是低级接口\n  - 2. Promise中的多异步协作\n    - Deferred.prototype.all\n  - 3. Promise的进阶知识\n    - Promise的秘诀其实在于对队列的操作\n    - 支持序列执行的Promise - `promise().then(obj.api1).then(obj.api2)`\n    - 将API Promise化\n- 3、流程控制库\n  - 1. 尾触发与Next\n    - 需要手工调用才能持续执行后续调用的， 我们将此类方法叫做尾触发， 常见的关键词是next。\n    - Connect的中间件应用\n  - 2. async\n    - 流程控制模块async\n    - series()串行、parallel()并行、waterfall()依赖处理、auto()自动依赖处理\n  - 3. Step\n    - Step用到了this关键字\n  - 4. [wind](https://github.com/JeffreyZhao/wind) \n    - 当时思路很新颖，已经有后来async 和 await的雏形了\n    - eval(Wind.compile(\"async\", function() {}));\n    - $await();\n    - Wind.Async.sleep(20);\n  - 5、其他[streamlinejs](https://github.com/Sage/streamlinejs)\n#### 4、异步并发控制\n> 解决并发量过大的问题\n- bagpipe的解决方案\n  - 主要通过一个队列来控制并发量\n  - bagpipe类似于打开了一道窗口，允许异步调用并行进行，但是严格限定上限。 \n  - 考虑拒绝模式（太多就不接受了）、超时控制\n- async的解决方案\n  - parallelLimit\n  - queue：动态地增加并行任务\n\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-3异步I/O","url":"/2024/03/08/Nodejs/3/","content":"#### 导论\n- 异步早就存在于操作系统的底层，在底层系统中， 异步通过信号量、 消息等方式有了广泛的应用\n- 在众多高级编程语言或运行平台中， 将异步作为主要编程方式和设计理念的， Node是首个\n\n#### 1、为什么要异步I/O\n> 更快地影响资源，响应时间Max(M,N)，前端体验更好\n> 更合理的利用后端的资源\n- 1、`用户体验`（前端），\n  - JavaScript在单线程上执行，与UI渲染共用一个线程\n  - 前端通过异步可以消除掉UI阻塞的现象\n  - 更快地响应资源，消除阻塞的影响，\n- 2、`资源分配`（后端）\n  - 单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。 \n  - 多线程编程模型也因为编程中的死锁、 状态同步等问题让开发人员头疼\n  - Node在两者之间给出了它的方案： \n    - 利用单线程， 远离多线程死锁、 状态同步等问题；\n    - 利用异步I/O， 让单线程远离阻塞，同时使用子进程，以更好地使用CPU。\n\n#### 2、异步I/O实现现状\n> 计算机内核层面如何I/O，阻塞和非阻塞，如何实现底层的异步高效查询\n- 实际效果而言，异步和非阻塞都达到了我们并行I/O的目的。 \n- 但是从计算机内核I/O而言， 异步/同步和阻塞/非阻塞实际上是两回事\n- 阻塞I/O vs 非阻塞I/O\n  - 阻塞I/O -> 等待\n  - 非阻塞I/O -> 立即返回 -> 是状态 -> 轮询来获取完整数据\n  - 轮询有很多种，最终采用epoll，但是依旧有问题，使用自定义线程池完成\n  - 技术发展\n    - linux\n      - Linux下效率最高epoll技术（事件通知、回调，不是遍历查询，不浪费cpu）\n      - 但是对于应用程序而言（应用程序在上层，不知道底层具体发生了什么，因为还是在等），它仍然只能算是一种同步\n      - epoll休眠期间CPU几乎是闲置的，等于说其他的底层调用，依旧需要等待\n      - 只需在I/O完成后通过信号或回调将数据传递给应用程序即可\n      - AIO 支持异步，但是有缺陷\n      - libeio(采用线程池与阻塞I/O模拟异步I/O) -> 最终：自定义线程池来完成异步I/O\n    - windows\n      - IOCP\n      - 内部其实仍然是线程池原理， 不同之处在于这些线程池由系统内核接手管理\n      - 与Node的异步模型十分接近\n  - js这一层是单线程，但是底层是多线程\n    - 相对而言，Node是单线程的， 这里的单线程是JavaScript执行在单线程中。\n    - 在Node中， 无论是*nix还是Windows平台， 内部完成I/O任务的另有线程池。\n\n#### 3、Node的异步I/O\n> Node的执行模型：事件循环、观察者和请求对象\n> \n> IOCP底层如何实现的思路\n- 事件循环\n  - 类似while(true)的循环 \n  - -> Tick(执行一次循环体) \n  - -> 查看是否有事件待处理\n  - -> 如果有，就取出事件及其相关的回调函数，并执行回调\n  - -> 进入下个循环，是否还有其他事件\n  - -> 如果没有，退出进程\n- 观察者\n  - 在每个Tick的过程中，是否有事件需要处理呢？\n  - 每个事件循环中有一个或者多个观察者， \n  - 而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件\n  - 循环 - 做菜\n  - 观察者 - 服务台小妹\n  - 客人点单 - 回调\n  - 收到下单 - 就是一个事件\n  - 事件循环 - 典型的生产者/消费者模型\n    - 异步I/O、 网络请求等则是事件的生产者， 源源不断为Node提供不同类型的事件， \n    - 这些事件被传递到对应的观察者那里， \n    - 事件循环则从观察者那里取出事件并处理\n- 请求对象\n  - IOCP实现\n  - 发出调用后， 到回调函数被执行， 中间发生了什么呢？请求对象\n  - js代码 -> fs.open() -> c++核心代码 -> 核心模块 -> 内建模块 -> libuv调用 ->\n  - uv_fs_open()调用过程中创建：FSReqWrap请求对象（js层的参数和当前方法都被封装在上边）\n  - 回调函数 -> 放在oncomplete_sym属性上 -> \n  - 调用QueueUserWorkItem()，将请求对象推入线程池等待执行\n    - 第一个参数：uv_fs_thread_pro，第二个参数：所需参数（请求对象）\n    - uv_fs_thread_proc()方法会根据传入参数的类型调用相应的底层函数。 以uv_fs_open()为例，实际上调用fs__open()方法。\n  - JavaScript调用立即返回， 由JavaScript层面发起的异步调用的第一阶段就此结束\n- 执行回调\n  - 线程池中的I/O操作调用完毕之后， \n  - 会将获取的结果储存在req>result属性上\n  - 调用PostQueuedCompletionStatus()通知IOCP， 告知当前对象操作已经完成\n  - PostQueuedCompletionStatus作用是向IOCP提交执行状态， 并将线程归还线程池\n  - 提交的状态， 可以通过GetQueuedCompletionStatus()提取\n  - 还动用了事件循环的I/O观察者\n    - 在每次Tick的执行中，\n    - 它会调用IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求\n    - 如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理\n    - I/O观察者回调函数的行为就是\n    - 取出请求对象的result属性作为参数，\n    - 取出oncomplete_sym属性作为方法， \n    - 然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。\n  ![](./img/3.3.1.png)\n\n#### 4、非I/O的异步API\n> 主讲setTimeout/setInterval/setImmediate/process.nextTick()区别\n\n- setTimeout/setInterval\n  - 实现原理与异步I/O比较类似， 只是不需要I/O线程池的参与\n  - 创建的定时器会被插入到定时器观察者内部的一个红黑树中\n  - 每次Tick执行时， 会从该红黑树中迭代取出定时器对象， 检查是否超过定时时间\n  - 如果超过，就形成一个事件，它的回调函数将立即执行\n  - setInterval是重复性的检测和执行\n  - 不足：\n    - 非精确，一次循环占用时间过多，产生阻塞，那么就会超时\n    - 定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能\n- process.nextTick()\n  - 优点：操作相对较为轻量\n  - 每次调用process.nextTick()方法，只会将回调函数放入队列中\n  - 定时器中采用红黑树的操作时间复杂度为O(lg(n))， nextTick()的时间复杂度为O(1)\n- setImmediate\n  - process.nextTick()优先级要高于setImmediate()\n  - 观察者顺序\n    - 在于事件循环对观察者的检查是有先后顺序的， \n    - process.nextTick()属于idle观察者， \n    - setImmediate()属于check观察者\n    - idle先于I/O,I/O先于check\n  - 存储类型\n    - process.nextTick()的回调函数保存在一个数组中， \n    - setImmediate()的结果则是保存在链表中\n\n#### 5、事件驱动与高性能服务器\n- Node\n  - 对于网络套接字的处理， Node也应用到了异步I/O， \n  - 网络套接字上侦听到的请求都会形成事件交给I/O观察者。 \n- Apache\n  - 每线程/每请求的方式目前还被Apache所采用\n- Nginx\n  - Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，\n  - 用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺\n- 其他平台\n  - 没有成功异步I/O\n  - 同步I/O库的存在，异步不是主流，及时实现也未必能流行起来\n  - 异步I/O实现，其主旨是使I/O操作与CPU操作分离\n  - Tim Caswell将Node的这套思想重新移植到了Lua平台， 该项目叫luavit。","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-2模块机制","url":"/2024/03/07/Nodejs/2/","content":"#### 1、CommonJS规范\n> 这一章中主要讲了\n> \n> CommonJS规范是如何产生的，后端没有规范\n> \n> 以及CommonJS规范中的模块规范 require、exprots、module.exports\n- 1、出现\n  - CommonJS规范提出是旨在解决JavaScript在非浏览器环境中的模块化问题。\n  - 先有CommonJS规范，node采用了CommonJS规范\n- 2、模块规范\n  - 引用\n    ```js\n    var math = require('math');\n    ```\n  - 导出\n    - module.exports \n    ```js\n      // ok\n      exports.add = function () {\n        var sum = 0,\n          i = 0,\n          args = arguments,\n          l = args.length;\n        while (i < l) {\n          sum += args[i++];\n        }\n        return sum;\n      };\n      // 报错\n      // exports只是module.exports的一个引用\n      // exports重新赋值时,改变了他的引用\n      // exports将不再指向module.exports，而是指向一个新的对象\n      exports = function(){\n        console.log(1)\n      }\n    ```\n    - exports\n      ```js\n       //ok\n        module.exports = {\n          add:function () {}\n        }\n        // ok\n        module.exports = function (){\n          console.log(1)\n        }\n      ```\n  - 标识\n    - 模块标识其实就是传递给require()方法的参数\n    - 将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖\n    - 导出和引入机制使得用户完全不必考虑变量污染\n    - 下个章节有详细讨论\n\n\n#### 2、node的模块实现\n> 这一章中主要讲了\n> \n> 比较细致的阐述：node如何加载模块\n- 加载不同的模块：核心模块、文件模块，都进行缓存\n- 文件模块\n  - 路径形式的文件模块：模块路径（多层级的node_modules）、文件定位（目录、扩展名、包）如何解析，不同情况的处理\n  - 自定义模块，查找最慢\n- 编译不同模块:(缓存Module._cache对象上)\n  - .js模块（头尾包装，包装在了一个方法内部，隔离作用域，全局变量从形参中获取）、\n  - .node模块（不需要编译、process.dlopen()加载执行）、\n  - .json模块（require加载）\n#### 3、核心模块\n> 本章主要介绍了\n> \n> 核心模块组成，以及两部分如何加载、编译\n> \n> 核心模块引入流程（从上到下），以及编写核心组件\n\n- 核心模块分两部分\n  - javascript编写的（Node项目lib目录），\n    - 先转存为c/c++代码，生成node_natives.h头文件\n    - 编译，编译成功（缓存到NativeModule._cache对象上）\n    - process.binding('natives')取出放置在NativeModule._source\n  - c/c++编写的（Node项目src目录）（内建模块），\n    - NODE_MODULE宏将模块定义到node命名空间中,\n    - node_extensions.h 将内建模块统一放进了一个叫node_module_list的数组中\n    - get_builtin_module()从node_module_list数组中取出\n    - 如何导出\n      - Node在启动时，全局变量process，提供Binding()方法来协助加载内建模块\n      - Binding方法：\n        - 先创建一个exports空对象，调用get_builtin_module()方法取出内建模块对象，\n        - 通过执行register_func()填充exports对象，\n        - 最后将exports对象按模块名缓存，并返回给调用方完成导出。\n\n- 核心模块引入流程\n  - require(\"os\") -> NativeModule.require(\"os\") -> process.binding(\"os\") -> get_builtin_module(\"node_os\") -> NODE_MODULE(node_os,reg_func)\n\n- 编写核心模块\n  - js文件\n  - 编写头文件和编写C/C++文件\n  - 还需要更改src/node_extensions.h，在NODE_EXT_LIST_END前添加NODE_EXT_LIST_ITEM(node_hello)\n  - 让编写的两份代码编译进执行文件，同时需要更改Node的项目生成文件node.gyp\n\n#### 4、c/c++扩展模块\n> 本章主讲：\n> \n> 1、c/c++扩展模块的编写、编译、加载等\n> \n> 2、目前只需了解一下整个的过程，等学习c++以后，可以再重新编写\n- 1、c/c++扩展模块的优势，比js更有性能的优势（位运算）\n- 2、原生模块编译：\n  - 在不同的平台(linux\\windows)，\n  - 也是用了node-gyp\n  - 底层的编译工具链，用不同的编译软件(g++/gcc、vc++)，\n  - 生成不同的文件(.so、.dll)，\n  - 但都是.node\n- 3、c/c++扩展模块的\n  - 编写：.js、./hello/hello.cc(与内建模块有区别，没有node_module_list链表)\n  - 编译：GYP编译（跨平台）、node-gyp configure、node-gyp build、./build/Release/hello.node\n  - 加载：require、process.dlopen()、uv_dlopen()/uv_dlsym()(libuv库进行封装的)\n  - 优点：加载之后不需要编译、增强拓展\n\n\n#### 5、模块调用栈\n> 本章主讲：\n>\n> 模块之间的调用关系\n>\n> npm包\n- 模块之间的调用关系\n- ![](img/2.5.1.png)\n- 包\n  - 包结构\n  - 包描述文件package.json\n    - maintainers 维护者\n    - contributors 贡献者\n    - bugs bug反馈\n    - repositories 源代码\n    - homepage 当前包的网站地址\n    - bin 命令行工具\n- npm\n  - npm install -g name\n    - 全局模式这个称谓其实并不精确，存在诸多误导。 \n    - 实际上，-g是将一个包安装为全局可用的可执行命令\n  - npm adduser 注册\n  - npm owner 管理包的权限\n    - npm owner ls <package name>\n    - npm owner add <user> <package name>\n    - npm owner rm <user> <package name>\n  - npm ls分析包\n- 企业搭建自己的NPM仓库\n- 优良优秀的包\n  - 具备良好的测试。\n  - 具备良好的文档（README、 API） 。\n  - 具备良好的测试覆盖率。\n  - 具备良好的编码规范。\n  -更多条件。\n\n#### 6、前后端共用模块\n> 模块向前端的发展\n- 模块规范为了适用前端的场景，出现了异步模块定义\n- amd `define(id?, dependencies?, factory)`\n- cmd 与amd区别在于定义模块和依赖`引入`的部分\n- 当前这些都已经走进了历史，现在esmodule的天下了\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-1简介","url":"/2024/03/06/Nodejs/1/","content":"\n#### 1、诞生\n- 2009年，Ryan Dahl 发布\n\n#### 2、由来及发展\n> 这一章主要讲了\n> node使用js作为实现语言的由来：js符合作者预期\n> 和node名字的由来：网络功能节点\n- 1、作者的初衷就是\n  - 设计一款基于事件驱动、非阻塞I/O的Web服务器，达到高性能\n  - 评估了C、Lua、Haskell、Ruby，都不理想\n  - js评估\n    - js 后端历史包袱为零 采用非阻塞I/O\n    - 浏览器广泛的事件驱动\n    - v8高性能引擎\n  - node而生，js成为其实现语言\n- 2、为什么叫node\n  - 最后发展超过了他最初单纯开发一个Web服务器的想法\n  - 变成了构建网络应用的一个基础框架\n  - 包含：服务器、客户端、命令行工具\n  - 最终：\n    - 为一个强制不共享任何资源的单线程、单进程系统，\n    - 包含十分适宜网络的库，\n    - 为构建大型分布式应用程序提供基础设施\n    - 成为一个构建快速、可伸缩的网络应用平台\n  - 通过通信协议来组织许多Node，\n  - 非常容易通过扩展来达成构建大型网络应用的目的\n  - 每一个Node进程都构成这个网络应用中的一个节点\n  - 因此叫node就符合了这个款产品的定位\n\n\n#### 3、node 意义\n> 这一章讲了node诞生产生意义\n> 主要是js以后可以再服务器端大展拳脚\n> js在浏览器端和服务器端做了对比\n- 浏览器中局限\n  - h5和js的能力\n  - 来于webkit 和 v8\n  - 取决于浏览器中间层提供的支持有多少\n  - 长久以来却限制在浏览器的沙箱中运行\n- Nodejs 与 浏览器 对比\n  - 都是基于事件驱动的异步架构\n  - 浏览器\n    - 通过事件驱动来服务界面上的交互\n  - Node\n    - 通过事件驱动来服务I/O\n    - 并且功能得到拓展：随心所欲地访问本地文件，可以搭建WebSocket服务器端，可以连接数据库\n  - Node不处理UI，但用与浏览器相同的机制和原理运行\n  - 也有对两者同时运用的尝试\n    - 出现node-webkit这样的项目（2012年）\n      - Node中的事件循环和WebKit的事件循环融合在一起，\n      - 既可以通过它享受HTML、CSS带来的UI构建，\n      - 也能通过它访问本地资源，将两者的优势整合到一起\n    - github未找到项目（2024年），可能已经过时\n    - 像后来的nuxt是对此一种延续（我的理解）\n![img](https://res.weread.qq.com/wrepub/epub_26211935_3)\n\n\n#### 4、Node特点\n> 本章讲了Node的特点\n> 异步I/O：读取文件等、事件机制驱动：模拟浏览器、回调函数\n> 单线程：优点以及不足，child_process解决不足\n> 扩平台：libuv解决\n- 特点1：异步I/O\n  - 以读取文件为例，我们可以看到它与前端Ajax调用的方式是极其类似的\n  ```js\n    var fs = require('fs');\n    fs.readFile('/path', function (err, file) {\n      console.log(’读取文件完成’)\n    });\n    console.log(’发起读取文件’);\n  ```\n  - 在Node中，绝大多数的操作都以异步的方式进行调用。\n  - Ryan Dahl排除万难，在底层构建了很多异步I/O的API：例如文件读取、网络请求等\n  - 从语言层面很自然地进行并行I/O操作\n- 特点2：事件\n  - 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。\n  - 为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件\n    ```js\n        var http = require('http');\n        // 侦听服务器的request事件\n        http.createServer(function (req, res) {\n          var postData = '';\n          req.setEncoding('utf8');\n          // 侦听请求的data事件\n          req.on('data', function (chunk) {\n            postData += chunk;\n          });\n          // 侦听请求的end事件\n          req.on('end', function () {\n            res.end(postData);\n          });\n        }).listen(8080);\n        console.log(’服务器启动完成’);\n    ```\n  - 事件编程特点：轻量级、松耦合、只关注事务点等优势\n  - 问题：事件与事件之间各自独立，如何协作是一个问题。\n- 特点3：回调函数\n  - 回调函数无处不在\n  - 回调函数也是最好的接受异步调用返回数据的方式。\n- 特点4：单线程\n  - Node保持了JavaScript在浏览器中单线程的特点\n  - 优点：\n    - 避免了多线程问题\n    - 多线程编程那样处处在意状态的同步问题\n    - 这里没有死锁的存在，\n    - 也没有线程上下文交换所带来的性能上的开销\n  - 不足：\n    - 无法利用多核CPU\n    - 错误会引起整个应用退出，应用的健壮性值得考验\n    - 大量计算占用CPU导致无法继续调用异步I/O\n  - 解决不足：\n    - Node采用了与Web Workers相同的思路\n    - 来解决单线程中大计算量的问题：child_process\n      - 从容地应对单线程在健壮性和无法利用多核CPU方面的问题。\n      - 将计算分发到各个子进程，\n      - 可以将大量计算分解掉，\n      - 然后再通过进程之间的事件消息来传递结果，\n      - 这可以很好地保持应用模型的简单和低依赖\n- 特点5：跨平台\n  - Node基于libuv实现跨平台的架构示意图\n  - 兼容Windows和*nix平台主要得益于Node在架构层面的改动\n  - 它在操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv。\n  - 目前，libuv已经成为许多系统实现跨平台的基础组件\n  - Node的第三方C++模块也可以借助libuv实现跨平台。\n  \n\n#### 5、应用场景\n> 本章主要讲了Node的使用场景，包括\n> I/O密集型\n> 如胜任CPU密集型业务：c++扩展、子进程\n> 遗留系统：使用老接口\n> 分布式数据库查询\n-  1、I/O密集型\n   -  Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源\n   -  主要在于Node利用事件循环的处理能力\n-  2、CPU密集型业务\n   -  收否胜任？\n   -  V8的执行效率非常高，和其他语言相比速度也非常快\n   -  主要挑战是：js单线程，如果长时间运行计算，使得后续I/O无法发起\n   -  解决方法：\n      -  调整、分解大型运算任务为多个小任务，\n      -  运算适时释放，\n      -  不阻塞I/O调用发起\n      -  对于一个纯计算的场景，或许根本没有I/O，改用多线程\n      -  Node没有多线程，如何解决？\n         -  Node可以通过编写C/C++扩展的方式更高效地利用CPU\n         -  子进程处理\n      -  CPU密集不可怕，如何合理调度是诀窍\n-  3、遗留系统处理\n   -  对待原来的旧系统，譬如java/jsp\n   -  旧有的系统具有非常稳定的数据输出，持续为传统网站服务，\n   -  同时为移动版提供数据源，Node将该数据源当做数据接口，发挥异步并行的优势\n   -  旧系统只做接口和中间件\n-  4、分布式应用\n   -  并行地去多台数据库中获取数据并合并\n   -  NodeFox能实现对多台MySQL数据库的查询，如同查询一台MySQL一样，\n   -  而ITier更强大，查询多个数据库（不同的数据库）如同查询单个数据库一样\n   -  Node高效利用并行I/O的过程，也是高效使用数据库的过程\n\n\n\n\n#### 总结\n- 第一篇讲的是一些概念，但是非常重要，例如异步、事件（事件驱动）、回调、非阻塞、I/O、libuv等\n- 之前java同事问我，node到底是个啥？我其实都没有答好，在他们看来是服务器应该像阿帕奇之类的，怎么还用js做开发呢，现在理解node其实是一个综合体，既包括服务器，也包括运行时的环境，使用v8\n","tags":["server","Nodejs"]}]