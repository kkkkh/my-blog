[{"title":"《深入浅出Node.js》-2模块机制","url":"/2024/03/07/Nodejs/2/","content":"#### 1、CommonJS规范\n> 这一章中主要讲了\n> \n> CommonJS规范是如何产生的，后端没有规范\n> \n> 以及CommonJS规范中的模块规范 require、exprots、module.exports\n- 1、出现\n  - CommonJS规范提出是旨在解决JavaScript在非浏览器环境中的模块化问题。\n  - 先有CommonJS规范，node采用了CommonJS规范\n- 2、模块规范\n  - 引用\n    ```js\n    var math = require('math');\n    ```\n  - 导出\n    - module.exports \n    ```js\n      // ok\n      exports.add = function () {\n        var sum = 0,\n          i = 0,\n          args = arguments,\n          l = args.length;\n        while (i < l) {\n          sum += args[i++];\n        }\n        return sum;\n      };\n      // 报错\n      // exports只是module.exports的一个引用\n      // exports重新赋值时,改变了他的引用\n      // exports将不再指向module.exports，而是指向一个新的对象\n      exports = function(){\n        console.log(1)\n      }\n    ```\n    - exports\n      ```js\n       //ok\n        module.exports = {\n          add:function () {}\n        }\n        // ok\n        module.exports = function (){\n          console.log(1)\n        }\n      ```\n  - 标识\n    - 模块标识其实就是传递给require()方法的参数\n    - 将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖\n    - 导出和引入机制使得用户完全不必考虑变量污染\n    - 下个章节有详细讨论\n\n\n#### 2、node的模块实现\n> 这一章中主要讲了\n> \n> 比较细致的阐述：node如何加载模块\n- 加载不同的模块：核心模块、文件模块，都进行缓存\n- 文件模块\n  - 路径形式的文件模块：模块路径（多层级的node_modules）、文件定位（目录、扩展名、包）如何解析，不同情况的处理\n  - 自定义模块，查找最慢\n- 编译不同模块:(缓存Module._cache对象上)\n  - .js模块（头尾包装，包装在了一个方法内部，隔离作用域，全局变量从形参中获取）、\n  - .node模块（不需要编译、process.dlopen()加载执行）、\n  - .json模块（require加载）\n#### 3、核心模块\n> 本章主要介绍了\n> \n> 核心模块组成，以及两部分如何加载、编译\n> \n> 核心模块引入流程（从上到下），以及编写核心组件\n\n- 核心模块分两部分\n  - javascript编写的（Node项目lib目录），\n    - 先转存为c/c++代码，生成node_natives.h头文件\n    - 编译，编译成功（缓存到NativeModule._cache对象上）\n    - process.binding('natives')取出放置在NativeModule._source\n  - c/c++编写的（Node项目src目录）（内建模块），\n    - NODE_MODULE宏将模块定义到node命名空间中,\n    - node_extensions.h 将内建模块统一放进了一个叫node_module_list的数组中\n    - get_builtin_module()从node_module_list数组中取出\n    - 如何导出\n      - Node在启动时，全局变量process，提供Binding()方法来协助加载内建模块\n      - Binding方法：\n        - 先创建一个exports空对象，调用get_builtin_module()方法取出内建模块对象，\n        - 通过执行register_func()填充exports对象，\n        - 最后将exports对象按模块名缓存，并返回给调用方完成导出。\n\n- 核心模块引入流程\n  - require(\"os\") -> NativeModule.require(\"os\") -> process.binding(\"os\") -> get_builtin_module(\"node_os\") -> NODE_MODULE(node_os,reg_func)\n\n- 编写核心模块\n  - js文件\n  - 编写头文件和编写C/C++文件\n  - 还需要更改src/node_extensions.h，在NODE_EXT_LIST_END前添加NODE_EXT_LIST_ITEM(node_hello)\n  - 让编写的两份代码编译进执行文件，同时需要更改Node的项目生成文件node.gyp\n\n#### 4、c/c++扩展模块\n> 本章主讲：\n> \n> 1、c/c++扩展模块的编写、编译、加载等\n> \n> 2、目前只需了解一下整个的过程，等学习c++以后，可以再重新编写\n- 1、c/c++扩展模块的优势，比js更有性能的优势（位运算）\n- 2、原生模块编译：在不同的平台(linux\\windows)，用不同的编译软件(g++/gcc、vc++)，生成不同的文件(.so、.dll)，但都是.node\n- 3、c/c++扩展模块的\n  - 编写：.js、./hello/hello.cc(与内建模块有区别，没有node_module_list链表)\n  - 编译：GYP编译（跨平台）、node-gyp configure、node-gyp build、./build/Release/hello.node\n  - 加载：require、process.dlopen()、uv_dlopen()/uv_dlsym()(libuv库进行封装的)\n  - 优点：加载之后不需要编译、增强拓展\n\n\n#### 5、模块调用栈\n> 本章主讲：\n>\n> 模块之间的调用关系\n>\n> npm包\n- 模块之间的调用关系\n- ![](img/2.5.1.png)\n- 包\n  - 包结构\n  - 包描述文件package.json\n    - maintainers 维护者\n    - contributors 贡献者\n    - bugs bug反馈\n    - repositories 源代码\n    - homepage 当前包的网站地址\n    - bin 命令行工具\n- npm\n  - npm install -g name\n    - 全局模式这个称谓其实并不精确，存在诸多误导。 \n    - 实际上，-g是将一个包安装为全局可用的可执行命令\n  - npm adduser 注册\n  - npm owner 管理包的权限\n    - npm owner ls <package name>\n    - npm owner add <user> <package name>\n    - npm owner rm <user> <package name>\n  - npm ls分析包\n- 企业搭建自己的NPM仓库\n- 优良优秀的包\n  - 具备良好的测试。\n  - 具备良好的文档（README、 API） 。\n  - 具备良好的测试覆盖率。\n  - 具备良好的编码规范。\n  -更多条件。\n\n#### 6、前后端共用模块\n> 模块向前端的发展\n- 模块规范为了适用前端的场景，出现了异步模块定义\n- amd `define(id?, dependencies?, factory)`\n- cmd 与amd区别在于定义模块和依赖`引入`的部分\n- 当前这些都已经走进了历史，现在esmodule的天下了\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-1简介","url":"/2024/03/06/Nodejs/1/","content":"\n#### 1、诞生\n- 2009年，Ryan Dahl 发布\n\n#### 2、由来及发展\n> 这一章主要讲了\n> node使用js作为实现语言的由来：js符合作者预期\n> 和node名字的由来：网络功能节点\n- 1、作者的初衷就是\n  - 设计一款基于事件驱动、非阻塞I/O的Web服务器，达到高性能\n  - 评估了C、Lua、Haskell、Ruby，都不理想\n  - js评估\n    - js 后端历史包袱为零 采用非阻塞I/O\n    - 浏览器广泛的事件驱动\n    - v8高性能引擎\n  - node而生，js成为其实现语言\n- 2、为什么叫node\n  - 最后发展超过了他最初单纯开发一个Web服务器的想法\n  - 变成了构建网络应用的一个基础框架\n  - 包含：服务器、客户端、命令行工具\n  - 最终：\n    - 为一个强制不共享任何资源的单线程、单进程系统，\n    - 包含十分适宜网络的库，\n    - 为构建大型分布式应用程序提供基础设施\n    - 成为一个构建快速、可伸缩的网络应用平台\n  - 通过通信协议来组织许多Node，\n  - 非常容易通过扩展来达成构建大型网络应用的目的\n  - 每一个Node进程都构成这个网络应用中的一个节点\n  - 因此叫node就符合了这个款产品的定位\n\n\n#### 3、node 意义\n> 这一章讲了node诞生产生意义\n> 主要是js以后可以再服务器端大展拳脚\n> js在浏览器端和服务器端做了对比\n- 浏览器中局限\n  - h5和js的能力\n  - 来于webkit 和 v8\n  - 取决于浏览器中间层提供的支持有多少\n  - 长久以来却限制在浏览器的沙箱中运行\n- Nodejs 与 浏览器 对比\n  - 都是基于事件驱动的异步架构\n  - 浏览器\n    - 通过事件驱动来服务界面上的交互\n  - Node\n    - 通过事件驱动来服务I/O\n    - 并且功能得到拓展：随心所欲地访问本地文件，可以搭建WebSocket服务器端，可以连接数据库\n  - Node不处理UI，但用与浏览器相同的机制和原理运行\n  - 也有对两者同时运用的尝试\n    - 出现node-webkit这样的项目（2012年）\n      - Node中的事件循环和WebKit的事件循环融合在一起，\n      - 既可以通过它享受HTML、CSS带来的UI构建，\n      - 也能通过它访问本地资源，将两者的优势整合到一起\n    - github未找到项目（2024年），可能已经过时\n    - 像后来的nuxt是对此一种延续（我的理解）\n![img](https://res.weread.qq.com/wrepub/epub_26211935_3)\n\n\n#### 4、Node特点\n> 本章讲了Node的特点\n> 异步I/O：读取文件等、事件机制驱动：模拟浏览器、回调函数\n> 单线程：优点以及不足，child_process解决不足\n> 扩平台：libuv解决\n- 特点1：异步I/O\n  - 以读取文件为例，我们可以看到它与前端Ajax调用的方式是极其类似的\n  ```js\n    var fs = require('fs');\n    fs.readFile('/path', function (err, file) {\n      console.log(’读取文件完成’)\n    });\n    console.log(’发起读取文件’);\n  ```\n  - 在Node中，绝大多数的操作都以异步的方式进行调用。\n  - Ryan Dahl排除万难，在底层构建了很多异步I/O的API：例如文件读取、网络请求等\n  - 从语言层面很自然地进行并行I/O操作\n- 特点2：事件\n  - 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。\n  - 为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件\n    ```js\n        var http = require('http');\n        // 侦听服务器的request事件\n        http.createServer(function (req, res) {\n          var postData = '';\n          req.setEncoding('utf8');\n          // 侦听请求的data事件\n          req.on('data', function (chunk) {\n            postData += chunk;\n          });\n          // 侦听请求的end事件\n          req.on('end', function () {\n            res.end(postData);\n          });\n        }).listen(8080);\n        console.log(’服务器启动完成’);\n    ```\n  - 事件编程特点：轻量级、松耦合、只关注事务点等优势\n  - 问题：事件与事件之间各自独立，如何协作是一个问题。\n- 特点3：回调函数\n  - 回调函数无处不在\n  - 回调函数也是最好的接受异步调用返回数据的方式。\n- 特点4：单线程\n  - Node保持了JavaScript在浏览器中单线程的特点\n  - 优点：\n    - 避免了多线程问题\n    - 多线程编程那样处处在意状态的同步问题\n    - 这里没有死锁的存在，\n    - 也没有线程上下文交换所带来的性能上的开销\n  - 不足：\n    - 无法利用多核CPU\n    - 错误会引起整个应用退出，应用的健壮性值得考验\n    - 大量计算占用CPU导致无法继续调用异步I/O\n  - 解决不足：\n    - Node采用了与Web Workers相同的思路\n    - 来解决单线程中大计算量的问题：child_process\n      - 从容地应对单线程在健壮性和无法利用多核CPU方面的问题。\n      - 将计算分发到各个子进程，\n      - 可以将大量计算分解掉，\n      - 然后再通过进程之间的事件消息来传递结果，\n      - 这可以很好地保持应用模型的简单和低依赖\n- 特点5：跨平台\n  - Node基于libuv实现跨平台的架构示意图\n  - 兼容Windows和*nix平台主要得益于Node在架构层面的改动\n  - 它在操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv。\n  - 目前，libuv已经成为许多系统实现跨平台的基础组件\n  - Node的第三方C++模块也可以借助libuv实现跨平台。\n  \n\n#### 5、应用场景\n> 本章主要讲了Node的使用场景，包括\n> I/O密集型\n> 如胜任CPU密集型业务：c++扩展、子进程\n> 遗留系统：使用老接口\n> 分布式数据库查询\n-  1、I/O密集型\n   -  Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源\n   -  主要在于Node利用事件循环的处理能力\n-  2、CPU密集型业务\n   -  收否胜任？\n   -  V8的执行效率非常高，和其他语言相比速度也非常快\n   -  主要挑战是：js单线程，如果长时间运行计算，使得后续I/O无法发起\n   -  解决方法：\n      -  调整、分解大型运算任务为多个小任务，\n      -  运算适时释放，\n      -  不阻塞I/O调用发起\n      -  对于一个纯计算的场景，或许根本没有I/O，改用多线程\n      -  Node没有多线程，如何解决？\n         -  Node可以通过编写C/C++扩展的方式更高效地利用CPU\n         -  子进程处理\n      -  CPU密集不可怕，如何合理调度是诀窍\n-  3、遗留系统处理\n   -  对待原来的旧系统，譬如java/jsp\n   -  旧有的系统具有非常稳定的数据输出，持续为传统网站服务，\n   -  同时为移动版提供数据源，Node将该数据源当做数据接口，发挥异步并行的优势\n   -  旧系统只做接口和中间件\n-  4、分布式应用\n   -  并行地去多台数据库中获取数据并合并\n   -  NodeFox能实现对多台MySQL数据库的查询，如同查询一台MySQL一样，\n   -  而ITier更强大，查询多个数据库（不同的数据库）如同查询单个数据库一样\n   -  Node高效利用并行I/O的过程，也是高效使用数据库的过程\n\n\n\n\n#### 总结\n- 第一篇讲的是一些概念，但是非常重要，例如异步、事件（事件驱动）、回调、非阻塞、I/O、libuv等\n- 之前java同事问我，node到底是个啥？我其实都没有答好，在他们看来是服务器应该像阿帕奇之类的，怎么还用js做开发呢，现在理解node其实是一个综合体，既包括服务器，也包括运行时的环境，使用v8\n","tags":["server","Nodejs"]}]