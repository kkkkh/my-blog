[{"title":"《深入浅出Node.js》- 总结篇","url":"/2024/03/09/Nodejs/13/","content":"\n>《深入浅出Node.js》10多年前出版的书，依旧经典耐读\n\n\n关于读《深入浅出Node.js》这本书有很多的感悟，就在此跟大家一一分享了\n\n首先我是如何读到这本书的，1年前学习nodejs，当时学的云里雾里，很多概念都不是很清晰，只会调取一些node的api，可以写一个服务后台，但是这种程度练习，早在几年前其实就有过，但是都是浅尝辄止，因此我去微信读书，搜索nodejs相关的书籍，找到一本评分较高的，就是这本《深入浅出Node.js》，然后开始了我的nodejs（1.0）深入学习。\n\n开始读了几章，发现这就是我想看的书籍，为什么呢？因为这本书的讲解，系统、深度、透彻来形容都不为过，读了前几章，之前萦绕在大脑的一些问题迎刃而解，比如：在第5章内存控制，v8垃圾回收原理，原来也知道一些新生代、老生代，别人一问深了，就不知道了，但是看完这一章相关的，就把v8垃圾回收原理都搞清楚了，等等，总之这是一本学习node的好书。\n\n后边继续阅读，大概阅读到7章左右，代码逐渐增多，发现一个问题？只阅读文章，不进行代码测试，有时候理解困难，即便理解了依然没有完全吃透，因此从后起，开始将示例代码逐一验证，在这个过程中进行学习理解，再后来关于单元测试第10章，给了我很大的启发，之前写代码几乎从未写过单元测试，这是多多大的遗憾和不足，单元测试虽费时间，但是长远来看又解释时间，将改bug的时间，用在了测试上，何乐而不为呢？\n\n后来种种原因，等到第11、12章的时候，就断了，开始其他事务，留了一个尾巴，因为今年又开始我第2次阅读，将没有看完的补上，看过的再复习一遍，2.0阅读开始。\n\n首先呢，我确实觉得读一本书，不能只看一遍，看一遍一是容易忘记，二是很多概念可能还没有理解透彻，但是`如何高效的读书`确实是我从2.0过程中有感悟出来的一个话题，这话题我们最后讲，现在先回顾下我如何第2次阅读的过程。\n\n第二次阅读，因为之前有一遍阅读了，我想有之前的映像，这边应该很快的，但是实际过程中低估了这本书的内容量，这本书是大概10年前作者完成的，虽然里边有一些技术，已经过时且废弃了，但是它对这些技术的使用思路、源码分析一点不过时，虽然可能不用这个技术，这个包，但是它的分析思路确实可以用到任何的新技术和新包当中，结果在这过程中，我还是花费了近一周的多的时间，才将所有章节的内容过完，这确实是我低估造成的\n\n第二呢我发现另外一个问题，就是这本书读在1年前，现在来看，除了一些章节有部分记忆点外（占本书的30%左右），有一些读过的章节，我居然好多内容没有映像了，那么我的第一遍的吸收率怎么会如此之低？去年做的笔记，有的看不太懂，有的就是废话一堆，这真是一件费力却不出效果的事情，想想自己这几年的技术学习，好像并不是只有这一本书是这样的，很多技术也都是这样，学过了也讲不出所以然，如果你花的时间比别人多，却还效果没有别人好，那么还是让我很有挫败感，要有所改变，必须提高效率\n\n结果这次确实也有所收获，笔记要写清，再看能看懂，但是感觉自己又陷入了另外一个误区，因为第一次读，效率不高，第二次要提高效率，对大部分知识点都做笔记，将讲解过程理解透，对每一个模块都进行测试，效果呢？只能说开始还可以，但是随着时间的推移，笔记越落越高，后边还能有映像，前边的又有遗忘了，想把所有都记住，到最后又可能还是只记住一点，真是该死啊。\n\n如何解呢？我们不能陷入到被动，也不能陷入到这个误区中无法自拔，其实回想下，你学习并不一定全部知晓，可以只知道其中大意即可，读完一章或一节，还是要回顾下，用一句话或者简短的话，描述下讲的是什么，将细节先过滤掉，比如垃圾回收原理，用一句话说垃圾回收原理就是：新生代用两块空间互换来回回收、老生代清除没有标记的内存；比如中间件代码实现原理：将中间件方法对应路由进行存储，接收到请求后再一次递归执行，采用第三个参数做尾调用；这样就出一个轮廓，再在此轮廓上描述细节填充回忆，只要有了这个大意，理解了基本原理，记不清的细节，再去查阅一遍，基本可以了解清晰，这是一个解决的方法\n\n面对千千万万的问题和细节，这是一个对我而言的好方法，所以前面的这一系列的文章，如果你阅读（还是推荐你阅读本书），就当是我的总结笔记吧，至于笔记还是要用自己的能看懂的语言描述清楚，确实可以在以后方便查阅\n\n最后再说下如何高效的读书，亦或是高效的学习吧，结合过往学习以及这两次阅读，我认为像《深入浅出Node.js》类似书籍呢，其实不用电子图书为好，电子图书有一个不足，我自身的感受，电子图书不方便查阅，你可以在对应章节中做标记，也可以写markdown，但是依旧不足。\n\n电子书做标记与纸质书做标记，在查阅上有很大的不同，比如你看到了第5章内容，你觉得之前在哪里看到过，你去查找你做的标记或者内容，有时候记忆不深的话，找起来很费力，但是纸质书可以一翻就找到了；当然电子书可以搜索或者查看自己的笔记，但是总感觉要翻到哪一页或者想观全貌的时候仍旧不足；至于markdown对电子书做笔记，复制粘贴自己觉得重点的内容，是一件很费时的事，而纸质书，在阅读过程中不需要这些；我读纸质书，先用黑笔做一次标记，在用红笔将重点圈出，一目了然，为此我又买了一本《深入浅出Node.js》纸质书，以方便后续记录、阅读、查阅。\n\n如果你有幸看到这篇文章，谢谢看我长篇大论的啰嗦，但是对我而言还是很有帮助的，也希望我的学习经验对你有所帮助。","tags":["Nodejs","book"]},{"title":"《深入浅出Node.js》- 12附录","url":"/2024/03/08/Nodejs/12/","content":">摘取附录中一些有用信息并更新：node如何在浏览器中调试、编码规范、搭建企业NPM仓库\n#### 调试Node\n- [新 debugging nodejs](https://nodejs.org/en/learn/getting-started/debugging)\n- node --inspect 12.2.js 启动服务\n- 打开Chrome浏览器，chrome://inspect\n- 确保你的Node.js应用程序正在运行。(代码中加个setTimeout 5就可以)\n- 在\"Remote Target\"部分，你应该看到你的Node.js进程\n\n#### Node编码规范\n- Douglas Crockford\n  - JSON、 JSLint、 JSMin和ADSafe之父\n  - JavaScript: TheGood Parts\n- 编码规范\n  - 空格与格式 eslint\n  - 命名规范\n  - 作用域 with eval\n  - 数组与对象\n    - 使用for in的异同(12.3.js)\n  - 注解规范 \n    - dox的注释规范 来源 jsDoc\n- 实践\n  - precommit这样的钩子脚本\n\n#### 搭建局域NPM仓库\n> 如何搭建、为什么搭建、如何优化\n- 搭建（过时）\n  - CouchDB 基于Erlang语言编写\n  - 两部分 www（界面）、registry（存储、api） \n  - 安装Erlang和CouchDB、搭建npm服务\n  - 同步官方仓库\n    - replicate实现 调取CouchDB接口，获取变动细节，同步缺失以及定时任务\n- 意义\n  - 解决：私有模块、网络稳定性影响安装速度、隐私问题安全问题\n  - 未解决：模块质量和版本控制中存在的风险\n- 优化方法\n  - 加入审核机制以及按需同步\n  - 1、全量同步变为按需同步：同步指定模块\n  - 2、审核机制：\n    - 公共模块：同步工程加审核机制，审核模块质量和安全、控制同步模块的权限，审核成功自动按需同步\n    - 企业私有模块：模块应该属于团队非个人、设置团队账号、管理员控制用户、团队账号发布、同时增加审核流程\n- 更新\n  - 最新搭建方法：\n    - npm Enterprise\n      - [npm Enterprise 废弃](https://docs.npmjs.com/enterprise)  -> [github packages](https://docs.github.com/en/packages/learn-github-packages/publishing-a-package) npm被github收购\n      - 实际是GitHub Packages充当了，私有库的角色，可以发布私有包，设置访问权限，供公司内部使用\n      - github packages集成了多种包，包含npm，[参考](https://docs.github.com/zh/packages/working-with-a-github-packages-registry/working-with-the-npm-registry)\n    - [Verdaccio](https://verdaccio.org/docs/what-is-verdaccio)","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》- 11产品化","url":"/2024/03/08/Nodejs/11/","content":"> node要实际作为一款产品运用，要多方面考虑：部署、性能、日志、监控、多机器、容灾备份等，实际中工作量非常多\n产品化\n- 1、工程化\n  - 目录结构\n  - 构建工具 \n    - Makefile make linux（过时）\n    - Grunt 媲美 java Maven（过时）\n    - webpack、vite\n  - 编码规范\n    - 一种是文档式的约定， \n    - 一种是代码提交时的强制检查\n    - JSLint和JSHint（过时）\n    - eslint（目前）\n  - 代码审查 \n    - gitlab\n    - 代码提交以后，审查再合并\n      - 功能是否正确完成、 \n      - 编码风格是否符合规范、（工具）\n      - 单元测试是否有同步添加\n- 2、部署\n  - 测试环境 stage\n  - 预发布环境 pre-release\n  - 生产环境 product\n  - 部署操作\n    - nohup node app.js &（以不挂断进程的方式执行）\n    - bash 脚本(11.2appctl.sh)：实现应用的启动、 停止和重启等操作\n- 3、性能\n  - 原则\n    - 做专一的事。\n    - 让擅长的工具做擅长的事情。\n    - 将模型简化。\n    - 将风险分离。\n  - 方法\n    - 动静分离\n      - 图片、脚本、样式表和多媒体等静态文件放到专业的静态文件服务器上\n      - 用Nginx或者专业的CDN来处理\n      - 静态内容，直接进行Buffer传输可以很大程度上提升性能\n    - 启用缓存 \n      - redis\n      - 具体场景：高并发读取场景、热点数据缓存、数据计算结果缓存、会话管理\n      - 启用redis带来了一些额外的复杂性：缓存一致性和缓存更新策略，需综合考虑\n    - 多进程架构 \n      - cluster\n      - pm、forever、pm2这样的模块用于进程管理\n    - 读写分离\n      - 读写分离，将数据库进行主从设计，这样读数据操作不再受到写入的影响\n      - 有一个主数据库（Master）和一个或多个从数据库（Slaves）。\n      - 所有的写操作都发送到主数据库，然后主数据库将写操作的日志传播给从数据库进行异步复制。\n      - 读操作可以从任意一个从数据库中进行，从数据库是只读的，并且与主数据库保持同步\n- 4、日志\n  - 访问日志 \n    - 中间件框架connect提供日志功能\n  - 异常日志 \n    - console.Console 实现自己的日志对象\n    - 每个开发者应当将API内部发生的异常作为第一个实参传递给回调函数\n    - 回调函数中产生的异常， 则可以不用过问， 交给全局的uncaughtException事件去捕获即可\n    - 异常尽量由最上层的捕获记录,底层只传递给上层\n    - 还要记着对日志进行格式化处理\n  - 日志文件/数据库（不推荐） \n    - 日志记录可以在线写（日志消息写入本地文件或输出到控制台。这种方式可以提供实时的日志记录，）\n    - 日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来（海量日志，日志分析工具同步到数据库，进行分析）\n  - 分割日志 \n    - 按日期分割，保存，方便排查使用\n- 5、监控报警\n  - 设置上限，一旦大的波动，发出警报\n  - 监控\n    - 5-1、日志监控 \n      - 异常日志的监控，按照异常类型、数量反应出来，\n      - 子系统相关的反应子系统\n      - QPS 检查业务在时间上的分布\n      - pv uv 使用者们的习惯、 预知访问高峰等。\n    - 5-2、响应时间\n      - 可以在nginx方向代理上监控\n      - 或者访问日志监控\n      - 健康的应该是波动较小的、持续均衡的\n    - 5-3、进程监控\n      - 检查工作进程的数量， \n      - 如果低于预估值， 就应当发出报警声。\n    - 5-4、磁盘监控 \n      - 用量 一旦不够用各种问题\n      - 设置一个上限， 一旦磁盘用量超过警戒值\n      - 就整理日志、清理磁盘\n    - 5-5、内存监控 \n      - 内存泄漏\n      - 只升不降，肯定内存泄漏\n      - 解决方法：多进程架构服务群，规定每个进程服务数量，满了，就启动新的，旧的逐次关闭\n    - 5-6、CUP占用监控 \n      - 如果用户态CPU使用率较高， 说明服务器上的应用需要大量的CPU开销； \n      - 如果内核态CPU使用率较高， 说明服务器花费大量时间进行进程调度或者系统调用； \n      - IOWait使用率则反应的是CPU等待磁盘I/O操作。\n      - 用户态小于70%、内核态小于35%且整体小于70%时，属于健康\n    - 5-7、CUP load监控（CPU负载均衡）  \n      - 描述操作系统当前的繁忙程度， \n      - CPU在单位时间内正在使用和等待使用CPU的平均任务数\n      - 三个指标：1分钟的平均负载、 5分钟的平均负载、 15分钟的平均负载\n      - CPU load过高说明：进程数量过多，可能用子进程模块反复启动新的进程。 \n    - 5-8、I/O负载 磁盘I/O\n      - 磁盘上的读写情况，也应监控\n    - 5-9、网络监控 \n      - 需要对流量进行监控并设置上限值\n      - 超过警戒值， 开发者就应当找出流量增长的原因\n      - 监控两个指标：流入流量和流出流量\n    - 5-10、应用状态监控\n      - 提供一种机制反馈自身的状态\n      - 外部持续调用反馈接口，进行检查\n      - 相关状态打印出来：数据库连接是否正常、缓存是否正常\n    - 5-11、DNS监控\n      - 实际服务产品，对域名都有依赖\n      - dns故障并大面积影响并不少见，重视\n      - 免费的DNS监控服务， 如DNSPod等\n  - 报警实现\n    - nodemailer模块 -> 邮件\n    - 短信、电话报警\n- 6、稳定性\n  - 多进程、 \n  - 多机器、 多机房\n  - 容灾备份\n  - 应用自身的部署考虑，如依赖的数据库、缓存等服务也要考虑。\n- 7、异构共存\n  - 一部分是在全新的项目中应用， \n  - 一部分是改造已有系统通过Node来提升性能。 \n  - 几乎没有将已有系统推翻用Node来进行重建的。\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》- 10测试","url":"/2024/03/08/Nodejs/10/","content":"> 从单元测试、性能测试两个维度进行讲解，重视测试，并在项目中使用，事半功倍\n#### 单元测试 \n好代码，比较好写单元测试，相互促进\n不好的代码，需要重构，再写单元测试\n- 原则\n  - 1、单一职责，一段代码只做一件事，方便编写测试\n  - 2、接口抽象，针对接口进行测试，具体实现变化不影响测试单元\n  - 3、层次分离，mvc 逐层测试，逐层保证\n- 1、断言：断言就是单元测试中用来“保证最小单元是否正常”的检测方法；\n  - 测试第一步，看功能是否正常，对基本的判断；\n  - assert 模块：断言库大多都是基于assert模块进行封装和扩展的，这包括著名的should.js断言库\n- 2．测试框架：\n  - 断言检查失败会停止整个应用\n  - 实际应该：记录下抛出的异常并继续执行，最后生成测试报告；应用测试框架\n  - 它本身并不参与测试， 主要用于管理测试用例和生成测试报告，\n  - mocha\n    - 测试风格\n      - TDD 测试驱动开发 suite test\n        - TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例\n        - TDD的表述方式偏向于功能说明书的风格\n      - BDD 行为驱动开发 describe it\n        - BDD关注整体行为是否符合预期，适合自顶向下的设计方式\n        - BDD的表述方式更接近于自然语言的习惯\n      - 单元测试框架 mocha\n    - 测试报告\n      - 报告格式 \n        - mocha --reporters 可以查看所有报告格式\n        - mocha -R json\n        - json 通用、html-cov 可视化查看代码覆盖率\n      - 看文档\n- 3、测试代码的文件组织\n  - 测试代码放test文件夹\n- 4、测试用例\n  - 基本包括：至少一个断言、正向测试和反向测试\n  - (对于node还有)异步测试 done、超时设置如何设置 this.timeout(500)\n- 5、测试覆盖率：（重要指标）\n  - 如何判断单元测试对代码的覆盖情况， 我们需要直观的工具来体现。 \n  - jscover模块 （java）、lanket模块 （纯js模块，解决jscover不足）（都过时）\n- 6、mock\n  - 模拟异常\n  - 我们通过伪造fs.readFileSync()方法抛出错误来触发异常。\n  - 同时为了保证该测试用例不影响其余用例，我们需要在执行完后还原它\n  - 推荐模块 muk（过时）\n- 7、私有方法\n  - rewire模块提供了一种巧妙的方式实现对私有方法的访问。\n  - 原理：引入文件，设置全局__get__()方法，eavl执行\n- 8、工程化、自动化\n  - 工程化 Makefile\n  - 持续集成 travis-ci\n- 其他：\n  - supertest 支持express等web框架测试\n#### 目前使用框架：\n- 之前都是偏于零散模块处理，单元测试，后边发展出集成度高的测试框架Jest等\n- 后端：\n  - [jest](https://jestjs.io/docs/getting-started) 内置断言库、配置相对简单（前端也可以）\n  - [mocha](https://mochajs.org/) 丰富、灵活可定制\n  - Tap 小众\n- 前端交互：\n  - [Puppeteer](https://pptr.dev/)\n    - 擅长测试前端交互和用户体验\n    - api简单高效\n  - [cypress](https://www.cypress.io/)\n    - 不仅适用于测试 Web 应用程序\n    - 还可以用于数据爬取、屏幕截图、性能分析等更广泛的用途\n    - api更丰富\n#### 性能测试\n- 检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力\n- 负载测试\n- 1、基准测试\n  - 在多少时间内执行了多少次某个方法\n  - benchmark模块\n    - 并不简单的统计次数时间\n    - 它对测试有着严密的抽样过程\n- 2、压力测试\n  - 吞吐率、\n  - 响应时间、\n  - 并发数\n  - 工具：\n    - ab、\n      - ab -c 10 -t 3 http://localhost:8001/\n      - 十个并发数、3秒内\n      - Requests per second：\n        - 这是我们重点关注的一个值，它表示服务器每秒能处理多少请求，是重点反映服务器并发能力的指标。\n        - 这个值又称RPS或QPS。\n      - 结果的每一个字段的意义，可以查看书中具体的对应解释\n    - siege、\n    - http_load\n- 3、基准测试驱动开发 BDD\n  - Benchmark Driven Development\n  - 大致思路：\n    - (1) 写基准测试。(2) 写/改代码。(3) 收集数据。(4) 找出问题。(5)回到第(2)步。\n  - 帮助写测试\n- 4、测试数据与业务数据的转换\n  - 评估业务量，以便系统可以胜任在线任务量\n  - 假设每天访问量是100w，集中在10小时以内，\n  - 那么100w/100h= qp约等于27.7，\n  - 每秒处理27.7个请求才能胜任业务","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》- 9进程","url":"/2024/03/08/Nodejs/9/","content":"#### 1、更好的使用node\n- 充分利用多核cpu服务器\n- 保证进程的健壮性、稳定性：单线程一旦异常、引起珍格格进程崩溃\n\n\n#### 2、服务器模型的变迁\n|date|进程数|特点|qps(每秒查询率)|服务器|\n|---|---|---|---|---|\n|石器时代：同步|1|一个请求N秒|1/N||\n|青铜时代：复制进程|M|进程数上限M|M/N||\n|白银时代：多线程|M\\*L（线程数）|一个线程服务一个请求；每个线程占用内存；频繁切换上下文；|M\\*L/N|Apache：C10k问题|\n|黄金时代：事件驱动||Cpu的利用率、健壮性；php：没有线程的支持、每个请求建立独立的上下文；Node：所有的请求的上下文是统一的、CPU的计算能力||Node与Nginx、Php|\n\n\n#### 3、多进程架构\n> 实现了只监听一个端口，多进程服务的架构\n- Master-Worker模式，又称主从模式(9.3.1/master.js和worker.js)\n- 创建子进程\n  - child_process 四个方法的区别spawn、exec、execFile、fork(9.3.2/child.js)\n- 通信：\n  - 进行send发送，message事件接受(9.3.3/IPC/)\n  - 通信原理：IPC \n    - Inter-Process Communication，即进程间通信\n    - 使用的是管道（pipe）技术\n    - 实现：\n      - Windows 命名管道（named pipe）实现，\n      - *nix Unix Domain Socket实现\n    - 原理：\n      - 1、父进程再创建子进程前，会创建IPC通道并监听它；\n      - 2、再去创建子进程，通过NODE_CHANNEL_FD告诉子进程IPC通道的文件描述符；\n      - 3、子进程启动时，根据文件描述符，连接IPC通道；\n      - 系统内核完成的通信，不经过网络层\n  - 句柄：\n    - 遇到的问题：服务器监听各自端口，如果都监听同一个端口，报错，希望多进程监听一个端口\n    - 解决思路：代理方案\n      - 主进程监听主端口（80）\n      - 子进程监听不同的端口\n      - 主进程接到请求，代理到不同的进程中\n      - 不足：主从关系至少要2个文件描述符，影响系统的扩展能力\n    - 解决思路二：句柄\n      - 只使用一个描述符\n      - `child.send(message, [sendHandle])`sendHandle句柄\n      - 句柄是：一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符\n      - 去掉代理，主进程接受到socket后，将这个socket发送给工作进程，解决描述符浪费的问题\n        - 单个子模块（9.3.3/handle-single-child）\n        - 多个子模块（9.3.3/handle-mutl-child）\n        - http（9.3.3/handle-http）主进程关闭服务器的监听，只让子进程来处理\n      - 句柄发送到底如何做到可以只监听一个端口的呢\n      - 过程：\n        - 1、send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。\n        - 2、message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化，最终都是字符串\n        - 3、子进程链接ipc通道，读取父进程发的消息，将字符串通过JSON.parse()解析还原为对象后\n        - 这个过程中，消息对象还要被进行过滤处理，如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象，还原过程\n      - 发送的的实际上是句柄描述符，接受的是同一个，这个过程中JSON转化了一遍\n      - 独立进程中的socket描述符不相同，监听同一个端口报错，底层规定：就不同的进程，可以就相同的网卡、端口进行监听，套接字可以被不用的进程复用，因此问题解决\n\n\n#### 4、集群稳定之路\n> 为了多进程服务的稳定，也要考虑工作进程存活状态管理、平滑启动、配置动态载入等\n- 进程事件\n  - error、exit、close、disconnect\n  - child.kill()/process.kill(pid,'SIGTERM') \n  - SIGTERM是软件终止信号\n  - 子模块接收到这个事件，process.exit(1)\n- 自动重启（9.4/restore）\n  - 主进程中，接收到一个子进程退出，重启一个新的进程继续\n  - 子进程监听uncaughtException事件，一旦触发，立即停止\n  - 自杀信号：\n    - 有可能子进程等待退出，新进程未启动，\n    - 得知要退出就发出`自杀信号`，\n    - 主进程接收到，就启动新的（在前）\n    - 达到平滑重启\n  - 设置一个超时退出\n- 限量重启（9.4/restore-limit）\n  - 解决：无限制频繁重启\n  - 添加日志、监控系统、进行报警\n- 负载均衡\n  - Round-Robin 轮叫调度\n  - 避免CPU和I/O繁忙差异导致的负载不均衡\n- 状态共存\n  - 第三方数据存储\n    - 数据发生变化，需要一种机制通知各个子进程\n    - 轮询（不建议）\n  - 主动通知\n\n\n#### 5、Cluster 模块（9.5/cluster）\n- 事实上cluster模块就是child_process和net模块的组合应用\n- 一个主进程只能管理一组工作进程\n- child_process 则可以更灵活地控制工作进程，甚至控制多组工作进程\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》- 8web应用","url":"/2024/03/07/Nodejs/8/","content":"\n#### 1、基础功能\n> 构建web应用考虑的基本功能\n1、函数作为参数，传递给createServer()方法\n2、请求方法处理 req.method\n3、路径解析 req.url（静态文件、路径对应控制器）\n4、查询字符串 ?foo=bar&baz=val\n5、cookie \n- 业务层面需要状态，区分身份\n- 响应的cookie，在Set-Cookie中\n  - Path 影响的路径\n  - Expires（具体时间）、Max-Age（多久后） 过期时间\n  - HttpOnly 不允许浏览器修改\n  - Secure https才有效\n- 性能：\n  - 减小cookie 域名相同都会带上\n  - 静态组件使用不同的域名\n- 广告：\n  - 标识用户，投放广告\n6、session\n- 数据保留在服务器，安全\n- 问题：\n  - 内存限制、进程之间内存不共享 \n- 解决：redis/memchaed\n  - 第三方redis问题：网络访问（但影响较小）\n- 安全：\n  - 使用一个私钥，签名session，进行加密，响应式作对比\n  - 攻击者获取口令和签名\n  - 将客户端的独有信息与口令，然后签名\n7、缓存\n- 在get请求中\n- 第一次请求：服务器内容\n- 第二次请求：\n  - 本地文件进行检查，不确定是否可用\n  - 发起一次条件请求，\n    - 附带If-Modified-Since字段\n    - 问服务有没有更改？没有，304，使用本地\n    - 更改了，放弃本地\n    - If-Modified-Since 事件戳问题：\n      - 内容改动、时间戳没有改动\n      - 只精确到妙级别，更频繁的无法生效\n      - 使用Etag\n    - Etag\n      - if-None-Match/ETag\n      - `req.headers['if-None-Match']`\n      - `res.setHeader(\"Etag\",hash)`\n      - 可以是根据文件内容生成散列值，进行对比\n  - 不发起请求\n    - 让浏览器明确地将内容缓存起来\n    - Expires\n      - `res.setHeader(\"Expires\",toUTCString())`\n      - 不足：前后端时间不一致\n    - Cache-Control头\n      - `res.setHeader(\"Cache-Control\",\"max-age=10000000\")`\n      - max-age：倒计时方式计算过期\n      - 还能设置public、private、no-cache、no-store更精细选型\n    - 这两个字段基本对应了cookie的字段\n- 8、Basic认证\n  - 检查报文头Authorization字段的内容\n  - 已废弃\n  - 摘要访问认证（改进Basic认证）\n  - oauth\n  - sso\n  - jwt\n\n\n#### 2、数据上传\n> 报文体解析、Content-Type常见类型、安全：内存、CSRF\n- node对报文体没有解析，自行解析\n  - 通过这两个字段：Transfer-Encoding（长度未知）或Content-Length（长度一致） 判断有没有内容\n  - 这两个字段互斥\n  - Transfer-Encoding:chunked 分成块逐个发送 \n- Content-Type 常见格式\n  - 接受处理思路：先接受内容，在解析格式\n  - `rawBody`是buffer拼接而成的\n  - Content-Type: application/x-www-form-urlencoded (<form>表单)\n    - 最简单：使用`querystring.parse(req.rawBody)`解析\n  - Content-Type: application/json;charset=utf-8\n    - json：`JSON.parse(req.rawBody)`解析\n  - Content-Type: application/xml;charset=utf-8\n    - xml：库xml2js `xml2js.parse(req.rawBody)`\n  - Content-Type: multipart/form-data; boundary=AaB03x (formdata)\n    - 提交文件：file类型的控件\n    - boundary=AaB03x指定的是每部分内容的分界符，随机生成的一段字符串\n    - 通过在它前面添加--进行分割，结束时在`前后边都加--`，标识结束\n    - 后边进行验证下\n  - 对于文件上传，上面这种处理思路变得不可接受，先处理格式，找到对应的处理方法\n  - 文件上传使用，模块formidable（8.2/upload）\n- 安全\n  - 内存\n    - 限制上传大小 （Transfer-Encoding/Content-Length两个字段来控制大小）\n    - 导向磁盘\n  - CSRF（Cross-Site Request Forgery）\n    - 场景：\n      - 留言中添加访问接口代码，或者邮件中诱导客户点击链接\n    - 过程\n      - 网站a是正常的，登录用户，发起过请求\n      - 网站b（黑客的）中添加网站a的请求\n      - 攻击者诱导客户从a登录用户访问b\n      - 到达b自动向a发送一个请求\n    - 解决\n      - 为每个请求的用户，在Session中赋予一个随机值，_csrf\n      - 将这个值告诉前端\n      - 每次请求都带上\n      - 服务端存储的随机值进行对比\n      - 伪代码中无法获取这个随机值，发起请求，则失效\n\n#### 3、路由解析\n> 路由解析三种思路：文件路径、mvc（映射）、restful\n- 文件路径\n  - 静态文件：url与路径一致\n  - 动态文件：（node不常见）\n    - 根据路径找到执行脚本，\n    - 根据文件后缀寻找文本解析器，执行脚本\n- MVC\n  - URL路径原来可以跟具体脚本所在的路径没有任何关系\n  - 包括\n    - 控制器（Controller），一组行为的集合。\n    - 模型（Model），数据相关的操作和封装。\n    - 视图（View），视图的渲染。\n  - 思路\n    - 路由解析，根据URL寻找到对应的控制器和行为\n    - 行为调用相关的模型，进行数据操作\n    - 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端\n  - 实现：如何根据URL做路由映射\n    - 1、手工映射(/8.3/handmap.js)\n      - 添加一个路由表，路径对应action\n      - 将请求的路径，解析，找到对应路由，执行action\n      - 复杂的使用正则匹配\n    - 2、自然关联映射(/8.3/naturemap.js)\n      - 尽是路由不如无路由\n      - 实质是路由按一种约定的方式自然而然地实现了路由，而无须去维护路由映射\n      - 将如下路径进行了划分处理\n      - /user/setting/12/1987为例，\n          - 它会按约定去找controllers目录下的user文件，\n          - 将其require出来后，调用这个文件模块的setting()方法\n          - /12/1987作为参数传递\n        - php ci框架中应用十分广泛\n- RESTful\n  - （Representational State Transfer） 表现层状态转化\n  - 将服务器端提供的内容实体看作一个资源\n  - 对这个资源的操作，主要体现在HTTP请求方法上，不是体现在URL上\n    ```js\n    POST /user/jacksontian        \n    DELETE /user/jacksontian        \n    PUT /user/jacksontian        \n    GET /user/jacksontian\n    ```\n  - 资源的具体格式由请求报头中的Accept字段和服务器端的支持情况来决定\n    - `Accept: application/json, application/xml`\n  - 综述：\n    - `app.post('/user/:username',addUser)`\n    - 通过URL设计资源`/user/:username`\n    - 请求方法定义资源的操作 `GET POST`\n    - 通过Accept决定资源的表现形式 `Accept: application/json, application/xml`\n  - 具体实现\n    - routes改为method对应结构，app也改为method对应结果\n    - app.use()注册一个路由，填充到routes和app\n    - 根据req.url和req.method进行解析，找到对应路由以及处理函数\n\n#### 4、中间件\n> 中间件实现思路\n- 定义\n  - 将细节按照不同的功能“公共功能”（基础设施）和“业务逻辑”进行分离；\n  - 封装底层细节，为上层提供更方便服务\n- 原理：尾触发\n  - 1、注册use的时候，将中间件push到路由对应stack[]中\n  - 2、url进行match路由的时候（接受请求），匹配到，将对应stack传到第三个参数，继续进行handle执行操作\n  - 3、执行的时候，从stack中shift出，判断有没有中间件，如果有则执行当前中间件\n  - 4、因为stack有可能有多个中间件，将stack传给当前执行中间件的第三个参数（递归）\n  - 5、中间件都改为，有第三个参数的模式，执行玩自己的内容，走第三个参数（尾调用）next，即下一个中间件\n  - 6、增加路由共同的中间件、各自的中间件\n- 特点：职责单一、可扩展、可组合\n-  性能：\n   - 1、编写高效中间件；\n       - 高效方法 `jsperf.com`测试基准性能\n       - 缓存需要重复计算的结果\n       - 避免不必要的计算\n   - 2、合理利用路由，避免不必要的中间件执行；\n       - 只有/public路径会匹配上，其余路径根本不会涉及该中间件\n       - `app.use('/public', staticFile);`\n\n\n#### 5、页面渲染\n> 页面渲染需要考虑的因素以及实现原理\n- 内容响应\n  - 响应报头中的 Content-\\*字段十分重要\n  - 1、MINI\n  - 2、下载附件\n    - Content-Disposition字段应声登场\n    - Content-Disposition: attachment; filename=\"filename.ext\"\n  - 3、响应JSON\n  - 4、响应跳转\n- 视图渲染\n  - 模板技术：\n    - 模板语言\n    - 包含模板语言的模板文件\n    - 拥有动态数据的数据对象\n    - 模板引擎\n  - 模版技术演化：\n    - 1.0：在CGI程序或servlet中输出HTML片段\n    - 2.0：动态网页技术，如ASP、PHP、JSP（模板极度依赖上下文）\n      - ASP、PHP、JSP而言，模板属于服务器端动态页面的内置功能\n      - 模板语言就是它们的宿主语言（VBScript、JScript、PHP、Java），\n      - 模板文件就是以．php、.asp、.jsp为后缀的文件，\n      - 模板引擎就是Web容器\n    - 3.0 脱离上下文环境，但依赖宿主语言\n      - PHPLIB Template和FastTemplate、\n      - Java的XSTL，以及Velocity、JDynamiTe、Tapestry\n    - 4.0 破局者是Mustache\n      - 给出了十多门编程语言的模板引擎实现\n      - 可移植\n  - 模板技术本质- 拼接字符串这样很底层的活\n  - 实现考虑：\n    - 基础模板引擎（实现思路）：\n    ```js\n      // 中间函数\n      var complie = function (str) {\n        var tpl = str.replace(/<%=([\\s\\S]+? )%>/g, function(match, code) {\n          return \"' + obj.\" + code + \"+ '\";\n        });\n        tpl = \"var tpl = '\" + tpl + \"'\\nreturn tpl; \";\n        // Function构造函数\n        // new Function ([arg1[, arg2[, ... argN]], ] functionBody)\n        return new Function('obj, escape', tpl);\n      };\n      var render = function (complied, data) {\n        return complied(data);\n      };\n      var tpl = 'Hello <%=username%>.';\n      console.log(render(complie(tpl), {username: 'Jackson Tian'}));\n      // => Hello Jackson Tian.\n    ```\n    - with应用 支持不同变量\n    - 模版安全\n    ```js\n    var escape = function (html) {\n      return String(html)\n        .replace(/&(? ! \\w+; )/g, '&amp; ')\n        .replace(/</g, '&lt; ')\n        .replace(/>/g, '&gt; ')\n        .replace(/\"/g, '&quot; ')\n        .replace(/'/g, '&#039; '); // IE下不支持&apos;（单引号）转义\n    };\n    ```\n    - 字符转义，html字符转为安全字符\n    - 支持逻辑 if else\n    - 集成文件系统 将tpl模版放在文件中\n    - 子模版：支持复用\n    - 布局视图：父模版的复用\n    - 性能\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》- 7网络编程","url":"/2024/03/07/Nodejs/7/","content":"> tcp、udp、http、htps、websocket中如何使用\n> 还重点分析了websocket数据传输的过程、ssl/tls和https如何进行数字签名\n#### 服务模块\nNode提供了net、dgram、http、https这4个模块，\n分别用于处理TCP、UDP、HTTP、HTTPS，\n适用于服务器端和客户端。\n\nnet -> TCP  => tls -> TLS/SSL加密的TCP连接上\ndgram -> UDP\nhttp -> HTTP => https -> HTTPS\n\n#### OSI模型\n\n![](./img/7.1.png)\n\n#### 1、TCP\n- 传输之前需要3次握手形成会话\n- 创建会话\n- 测试\n  - 创建服务端(7.1.1.js)\n  - telnet 127.0.0.1 8124\n  - nc -U /tmp/echo.sock （前提对domain socket监听 server.listen('/tmp/echo.sock');\n  - net模块自行构造客户端进行会话(7.1.2.js)\n\n#### 2、UDP\n- UDP 不是面向连接的、直接传输\n- DNS服务即是基于它实现的。\n\n#### 3、http\n- http\n  - HTTP标准为RFC 2616\n  - curl -v http://127.0.0.1:1337\n  - 报文开头：经典的TCP的3次握手过程\n  - 请求、响应：都包含报文头和报文体，get请求没有报文体\n- http 模块\n  - http 封装 net（tcp）\n  - HTTP服务以request为单位进行服务。 \n  - http模块即是将connection到request的过程进行了封装，\n  - 对二进制的数据进行解析：请求、响应过程中\n- 客户端\n  - http响应\n    - ClientRequest在解析响应报文时， \n    - 一解析完响应头就触发response事件， \n    - 同时传递一个响应对象以供操作ClientResponse\n  - http代理\n    - 最多可以创建5个连接，实际是一个线程池\n    - 需要修改\n    ```js\n    var agent = new http.Agent({\n      maxSockets: 10\n    });\n    var options = {\n      hostname: '127.0.0.1',\n      port: 1334,\n      path: '/',\n      method: 'GET',\n      agent: agent\n    }\n    ```\n    - agent为false，脱离连接池的管理，不受并发的限制。\n\n\n#### 4、websocket\n- 优点：\n  - 事件变成\n  - 长连接\n  - 只建立一个tcp连接\n  - 数据可以推动到客户端，双向通信\n  - 更轻量级的协议头\n- Comet技术 长轮询（过时）\n- WebSocket与HTTP的区别\n  - 相比HTTP,WebSocket更接近于传输层协议，在TCP上定义独立的协议。\n  - 让人迷惑的部分在于WebSocket的握手部分：是由HTTP完成的，使人觉得它可能是基于HTTP实现的。\n\n1、握手\n- 请求\n  ```YAML\n  GET /chat HTTP/1.1        \n  Host: server.example.com \n  # 升级协议为WebSocket \n  Upgrade: websocket        \n  Connection: Upgrade        \n  # 用于安全校验\n  # 随机生成的Base64编码的字符串\n  # 服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CAC5AB0DC85B11相连\n  # 然后通过sha1安全散列算法计算出结果后，Base64编码，返回给客户端\n  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==        \n  # 子协议和版本号  \n  Sec-WebSocket-Protocol: chat, superchat\n  Sec-WebSocket-Version: 13\n  ```\n- 响应\n  ```YAML\n  HTTP/1.1101 Switching Protocols\n  # 更新应用层协议为WebSocket协议\n  Upgrade: websocket        \n  Connection: Upgrade    \n  # 基于Sec-WebSocket-Key生成的字符串 \n  # 客户端将会校验Sec-WebSocket-Accept的值，如果成功，将开始接下来的数据传输   \n  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=        \n  Sec-WebSocket-Protocol: chat\n  ```\n2、数据传输\n  - send\n    - 将这个数据封装为一帧或多帧数据， 然后逐帧发送\n  - 安全\n    - 客户端需要对发送的数据帧进行`掩码处理`，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。\n    - 而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。\n  - 数据帧\n    - WebSocket数据帧的定义，每8位为一列，也即1个字节。其中每一位都有它的意义\n    - fin： \n      - 如果这个数据帧是最后一帧， 这个fin位为1， 其余情况为0。 \n      - 当一个数据没有被分为多帧时， 它既是第一帧也是最后一帧。\n    - rsv1、 rsv2、 rsv3： \n      - 各为1位长， 3个标识用于扩展， 当有已协商的扩展时， 这些值可能为1， 其余情况为0。\n    - opcode： \n      - 长为4位的操作码， 可以用来表示0到15的值， 用于解释当前数据帧。 \n      - 0表示附加数据帧， 1表示文本数据帧， 2表示二进制数据帧， 8表示发送一个连接关闭的数据帧， 9表示ping数据帧， \n      - 10表示pong数据帧， 其余值暂时没有定义。 \n      - ping数据帧和pong数据帧用于心跳检测， 当一端发送ping数据帧时， 另一端必须发送pong数据帧作为响应， 告知对方这一端仍然处于响应状态。\n    - masked： \n      - 表示`是否进行掩码处理`， 长度为1。 客户端发送给服务器端时为1， 服务器端发送给客户端时为0。\n    - payload length： \n      - 一个7、 7+16或7+64位长的数据位， 标识数据的长度， 如果值在0~125之间， 那么该值就是数据的真实长度； \n      - 如果值是126， 则后面16位的值是数据的真实长度； \n      - 如果值是127， 则后面64位的值是数据的真实长度。\n    - masking key： \n      - 当masked为1时存在， 是一个32位长的数据位， 用于解密数据。\n    - payload data： \n      - 我们的目标数据， 位数为8的倍数。\n  - 服务端处理\n    - 服务端接受，解析，通过掩码解密，触发onmessage\n    - 服务端响应，无需掩码，其他相同\n\n\n#### 5、服务安全\n- SSL作为一种安全协议（Secure Sockets Layer，安全套接层）- 传输层提供对网络连接加密\n- 随后IETF将其标准化，称为TLS（Transport Layer Security，安全传输层协议）\n- crypto、 加密解密\n- tls、 针对net tec\n- https、针对http\n1、TLS/SSL\n  - TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构\n  - 1、客户端和服务器分别生成公钥、私钥；\n    ```shell\n    # 生成服务器端私钥\n    $ openssl genrsa -out server.key 1024        \n    # 生成客户端私钥        \n    $ openssl genrsa -out client.key 1024\n    # 生成公钥\n    $ openssl rsa -in server.key -pubout -out server.pem       \n    $ openssl rsa -in client.key -pubout -out client.pem\n    ```\n  - 2、客户端和服务器端互换公钥，使用对方的公钥进行加密；\n  - 3、中间人攻击，\n    - 中间人对客户端扮演服务器端的角色， \n    - 对服务器端扮演客户端的角色，\n    - 为了解决这个问题， TLS/SSL引入了数字证书来进行认证、\n    - 数字证书包括：\n      - 1、服务器的名称和主机名、\n      - 2、服务器的公钥、\n      - 3、签名颁发机构的名称、\n      - 4、来自签名颁发机构的签名；\n    - 通过证书中的签名，确认收到的公钥是来自目标服务器的；\n  - 4、数字证书\n    - CA数字证书认证中心\n      - 为站点颁发证书， 且这个证书中具有CA通过自己的公钥和私钥实现的`签名`。\n      - 为了得到签名证书，\n      - 服务器需要通过自己的私钥生成CSR（Certificate Signing Request，证书签名请求）文件\n      - CA机构将通过这个文件颁发属于该服务器端的签名证书，\n      - 通过CA机构就能验证证书是否合法。\n      - 自签名证书：自己扮演CA机构\n      - CA：\n        - 生成私钥、\n        - 生成CSR文件、\n        - 通过私钥自签名生成证书（扮演CA角色需要的文件）\n        ```bash\n        $ openssl genrsa -out ca.key 1024        \n        $ openssl req -new -key ca.key -out ca.csr        \n        $ openssl x509-req -in ca.csr -signkey ca.key -out ca.crt\n        ```\n      - 服务器：\n        - 生成CSR文件、\n        - 得到签名证书\n        ```bash\n        $ openssl req -new -key server.key -out server.csr\n        $ openssl x509-req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt\n        ```\n    - 过程\n      - CA将证书颁发给服务器端\n      - 客户端先会去获取服务器端的证书\n      - 通过CA验证真假（还有服务器名称、IP地址验证）\n      - 知名的CA机构，它们的证书一般预装在浏览器中，不需要再从服务器获取了\n      - 根证书：不需要上级参与签名的\n2、TLS服务（/tls）\n  - 客户端：也需要生成CA证书，双向确认身份\n    ```js\n    // 创建私钥\n    $ openssl genrsa -out client.key 1024\n    // 生成CSR\n    $ openssl req -new -key client.key -out client.csr\n    // 生成签名证书\n    $ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt\n    ```\n3、https服务（/https）\n- 直接用上文生成的私钥和证书。\n- curl\n  - curl https://localhost:8000/ 抛错，无法验证服务器端证书是否正确，\n  - curl -k https://localhost:8000/ 忽略掉证书的验证\n  - curl --cacert keys/ca.crt https://localhost:8000/ 告知CA证书使之完成对服务器证书的验证","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-6理解buffer","url":"/2024/03/07/Nodejs/6/","content":"- buffer\n  - 各种场景下，要处理大量二进制数据，buffer应用而生\n#### 1、buffer结构\n> buffer的基本信息、内存分配\n1、模块结构（核心模块）\n  - 典型的JavaScript与C++结合的模块\n2、buffer对象(6.1.js)\n  ```js\n  var str = \"深入浅出node.js\";\n  var buf = new Buffer(str, 'utf-8');\n  console.log(buf);\n  // => <Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73>\n  ```\n  - 一个元素是16进制`两位`数,一个元素即一字节\n  - 一个`中文字符`在UTF-8编码下占用`3`个字节\n  - `字母`和`半角标点符号`占用`1`个字节\n3、buffer内存分配\n  - 采用slab分配机制\n  - full、partial、empty状态\n  - 以8kb为界线分配\n  - 小于8kb，\n    - 分配在一个8kb的slab单元中，\n    - 剩余空间足够，则再次分配到这个slab单元中\n    - 空间不足，创建新的slab\n    - 一直被占用，空间不被释放\n  - 大于8kb\n    - 直接分配一个SlowBuffer对象作为slab单元，独占\n  - 真正内存是c++层面提供的，js层面只是使用它\n\n#### 2、Buffer的转换\n> buffer转换\n1、字符串和buffer之间转化(6.2.js)\n2、buffer不支持的编码类型\n    - iconv-lite（纯JavaScript实现） \n    - iconv（C++调用libiconv库完成） \n#### 3、buffer的拼接\n> fs读取大文件是时候\n> buffer 如何拼接\n> 最终思路是（6.3.4.js）\n  将每一部分的buffer放到一个数组；\n  并记录整个buffer的长度；\n  最后拼接起来\n\n#### 4、buffer与性能\n- 网络传输中，使用buffer传输，提高网络吞吐率\n  - node 6.4.js (启动一个8001服务，res.end(buffer);)\n  - `ab -c 200 -t 100 http://127.0.0.1:8001/`\n  - 文件读取时，highWaterMark设置会对buffer内存有影响\n  - 设置越大，读取越快\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-5内存控制","url":"/2024/03/07/Nodejs/5/","content":"> 一个是垃圾回收：原理、如何查看；一个是内存：进程内存、堆外内存、内存泄漏原因以及排查等\n#### 1、V8的垃圾回收机制与内存限制\n> v8内存限制大小，为什么限制、垃圾回收机制、以及如何查看垃圾回收日志\n- 1、Node与v8\n  - Lars Bak 开发高性能的虚拟机工作背景\n  - 无与伦比的经历让V8一出世就超越了当时所有的JavaScript虚拟机。\n- 2、v8的内存限制\n  - 64位系统下约为1.4GB，32位系统下约为0.7 GB\n  - V8为何限制了内存的用量？\n  - 内存使用量的查看方式\n    ```bash\n    node\n    > process.memoryUsage();\n    { rss: 14958592,\n    heapTotal: 7195904,// v8申请到堆内存\n    heapUsed: 2821496 }// 当前使用量\n    ```\n  - 表层原因：为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。\n  - 深层原因：\n    - 是V8的垃圾回收机制的限制。\n    - 内存越大垃圾回收时间越多\n    - V8做一次小的垃圾回收需要50毫秒以上， \n    - 做一次非增量式的垃圾回收甚至要1秒以上\n    - 在当时的考虑下直接限制堆内存是一个好的选择。\n    - 使用更多内存\n      ```js\n      node --max-old-space-size=1700 test.js // 单位为MB（老生代）\n      // 或者\n      node --max-new-space-size=1024 test.js // 单位为KB（新生代）\n      ```\n  - 我曾在自己的项目中遇到过，服务器内存过小，导致vite启动打包失败\n- 3、V8的垃圾回收机制\n  - v8内存分代\n    - 新生代\n      - 存活时间较短的对象\n      - 两个reserved_semispace_size_所构成\n    - 老生代\n      - 较长、常驻\n  - v8的垃圾回收算法\n    - Scavenge算法（新生代、时间少）\n      - 采用 Cheney算法\n      - 内存一分为二， 每一部分空间称为semispace，\n      - 只有一个处于使用中（From空间）， 另一个处于闲置状态（To空间） \n      - 垃圾回收时， 会检查From中的存活对象，并且被被复制到To中，非存活对象占用的空间将会被释放。 \n      - 完成复制后， From空间和To空间的角色发生对换。（翻转）\n      - 当一个对象经过多次复制依然存活时，生命周期较长，随后会被移动到老生代中（晋升）\n      - 晋升两个条件：对象是否经历过Scavenge回收， 一个是To空间的内存占用比超过限制（超过25%）\n    - Mark-Sweep & Mark-Compact\n      - Mark-Sweep 标记清除\n        - 标记活着对象和清除没有被标记的对象\n        - 问题：内存碎片、不连续状态、不好分配大对象\n      - Mark-Compact 标记整理\n        - 解决sweep问题\n        - 对象在标记为死亡后，\n        - 在整理的过程中，将活着的对象往一端移动，移动完成后，\n        - 直接清理掉边界外的内存。\n      - v8中两种方法结合使用\n    - Incremental Marking 增量标记\n      - 以上三种算法执行时，应用逻辑暂停，为“全停顿”（stop-the-world） \n      - 老生代影响较大\n      - 解决：一口气停顿完成的动作，拆分为小“步进”\n      - 做一“步进”停下，就让应用逻辑执行，交替执行\n    - 延迟清理（lazy sweeping） 与增量式整理（incremental compaction）\n- 4、查看垃圾回收日志\n  - --trace_gc 看耗时\n    - node --trace_gc -e \"var a = [];for (var i = 0; i < 1000000; i++) a.push(new Array(100))\"\n    - 找出垃圾回收的哪些阶段比较`耗时`\n  - --prof\n    -  node --prof test01.js（5.1.js） //放一个1000000的for循环\n    -  得到一个v8.log日志文件，不具备可读性\n    -  linux-tick-processor v8.log\n    -  windows-tick-processor.bat v8.log\n       ```js\n       // 垃圾回收所占的时间为5.4%\n       [GC]:\n       ticks total nonlib name\n       2     5.4%\n       ```\n\n#### 2、高性能使用内存\n> 了解作用域、闭包以更好的使用内存\n- 1、作用域 scope\n- 2、闭包\n```js\n// 一旦有变量引用这个中间函数， 这个中间函数将不会释放， 同时也会使原始的作用域不会得到释放， \nvar foo = function () {\n  var bar = function () {\n    var local = \"局部变量\";\n    return function () {\n        return local;\n    };\n  };\n  var baz = bar();\n  console.log(baz());\n};\n```\n\n#### 3、内存指标\n> 进程内存（v8堆内存）以及如何查看、堆外内存\n1、查看内存使用\n  - 查看进程内存\n    - process.memoryUsage()(5.3.1.js)\n    - rss是resident set size的缩写， 即进程的常驻内存部分\n    - heapTotal 1367.99 MB heapUsed 1361.86 MB rss 1375.00 MB\n  - 查看系统内存\n    - os模块中的totalmem()和freemem()\n    ```js\n    node\n    > os.totalmem()\n    8589934592\n    > os.freemem()\n    4527833088\n    >\n    ```\n2、堆外内存（5.3.2.js）\n  - 使用buffer做测试案例\n  - Process: heapTotal 5.85 MB heapUsed 1.85 MB rss 3012.91 MB\n  - heapTotal与heapUsed的变化极小，唯一变化的是rss的值\n  - Buffer对象,它不经过V8的内存分配机制，不会有堆内存的大小限制。\n\n#### 4、内存泄漏\n> 内存泄漏会出现在哪些方面：缓存、队列、作用域，以及解决方案\n- 缓存\n- 队列消费不及时\n- 作用域未释放\n\n- 1、慎将内存当做缓存\n  - 常用对象的键值对来缓存东西\n  - 加上完善的过期策略以防止内存无限制增长，可以使用\n  - 1. 缓存限制策略，\n    - 加一种策略限制无限增长，limitablemap一旦超出就先进先出淘汰\n    - 模块机制中，模块编译后都会缓存，写模块时避免对象/数组无限制增长，添加清空队列的相应接口\n  - 2. 缓存解决方案\n    - 将缓存转移到外部：Redis、Memcached\n    - 进程之间可以共享缓存。\n- 2、关注队列状态（数组）\n  - 日志收集\n    - 表层解决方案：是换用消费速度更高的技术，换数据库为文件写入\n    - 深度：监控队列长度，一旦堆积、报警；任意异步调用包含超时机制\n\n#### 5、内存泄漏排查\n> 内存泄漏排查工具，如何使用\n- node-heapdump\n- node-memwatch\n- 模块较久更新，现在应该有更新的排查工具\n\n#### 6、大内存应用\n> 如何处理大文件：stream pipe\n- stream模块处理大文件(5.6.js)\n- fs的createReadStream()和createWriteStream()\n- 管道方法pipe()\n- 现在有功能更丰富的api，查阅node对应文档\n\n#### 实际案例回顾\n- 背景：\n  - 项目（直播平台），为了更好地seo，从前端项目升级为node项目，使用nuxt框架，单页面升级到ssr，\n- 代码迁移工作：\n  - nuxt支持vue，将之前代码js vue vuex状态管理，一并迁移，\n  - 未更新vuex状态管理使用方法，\n  - 导致数据错乱，一个直播间，会闪现别的直播间的数据\n  - 为什么未更新vuex状态管理使用方法就导致这个问题？\n- 分析：\n  - 1、由原前端浏览器环境，变为node服务器环境，对于访问用户而言，原来这套js每个浏览器下载一遍，数据不共用，而现在服务器端这套js大家是共用的；\n  - 2、vue状态管理的代码逻辑是，将主要的数据存储到了对象，这个对象大家是共用的，当多个用户大量访问，延时未及时更新时，就会出现错乱现象；\n  - 3、更新vuex的使用方法，vuex中存储的对象，改为函数调用返回一个新对象，做到数据的隔离，则问题解决","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-4异步编程","url":"/2024/03/06/Nodejs/4/","content":"#### 1、函数式编程\n> 函数式编程的相关概念\n- 函数一等公民 -> Scheme语言 -> Lisp的派生\n- 高阶函数\n  - 高阶函数则是可以把函数作为参数， 或是将函数作为返回值的函数\n  ```js\n  function foo(x) {\n    return function () {\n      return x;\n    };\n  }\n  ```\n  - 后续传递风格（Continuation Passing Style）\n    - 它的结果接收方式，将函数的业务重点从返回值转移到了回调函数中\n    ```js\n    function foo(x, bar) {\n        return bar(x);\n    }\n    ```\n    - 经典的例子便是数组的sort()方法,以及forEach等等\n  - 偏函数\n    - 创建一个调用另外一个部分（参数或变量已经预置的函数）的函数的用法\n    ```js\n    var isType = function (type) {\n      return function (obj) {\n        return toString.call(obj) == '[object ' + type + ']';\n      };\n    };\n    var isString = isType('String');\n    var isFunction = isType('Function');\n    ```\n    - 指定部分参数来产生一个新的定制函数的形式就是偏函数\n\n#### 2、异步编程优势和难点\n- 优势：之前多篇已复述\n- 难点：\n  - 异常处理\n  - 函数嵌套过深\n  - 阻塞代码 - sleep()\n  - 多线程编程（第9章重点叙述）\n  - 异步转同步\n\n#### 3、异步编程解决方案\n> 通过一下集中思路\n> \n> 事件发布、订阅模式；（代码演示）\n> promise/deferred；（原理分析，与事件比较）\n> 流程控制库（用法和源码分析）\n> \n> 来解决异步\n> \n> 现在来看技术都已经比较过时，es6+后续版本的支持，\n> async await语法糖、Generator 协程（coroutine）已经很好的解决了异步编程的难点，\n> \n> 但是分析这些模块的实现原理，对于模块、思路、代码的演变很有帮助\n\n- 1、事件发布/订阅模式\n  - 事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。\n  - Node自身提供的events模块\n  - 它具有addListener/on()、once()、removeListener()、removeAllListeners()和emit()等基本的事件监听模式的方法实现。\n  - 解耦业务逻辑， 事件发布者无须关注订阅的侦听器如何实现业务逻辑，甚至不用关注有多少个侦听器存在，数据通过消息的方式可以很灵活地传递\n  - 也是一种钩子（hook） 机制， 利用钩子导出内部数据或状态给外部的调用者\n  - 如果对一个事件添加了超过10个侦听器， 将会得到一条警告\n  - 为了处理异常， EventEmitter对象对error事件进行了特殊对待。 \n  - 1. 继承events模块\n  - 2. 利用事件队列解决雪崩问题\n  - 3. 多异步之间的协作方案，解决函数嵌套过深\n  - 接下来分析了EventProxy如何使用这种模式\n  - 4. EventProxy的原理\n  - 5. EventProxy的异常处理\n- 2、Promise/Deferred模式\n  - 使用事件的不足， 执行流程需要被预先设定\n  - Promise/Deferred模式最早出现于Dojo的代码中\n  - 广为所知则来自于jQuery 1.5版本\n  - 1. Promises/A\n    - 这里看到then()方法所做的事情是将回调函数存放起来。 \n    - 为了完成整个流程， 还需要触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred， 即延迟对象\n    - 与事件发布/订阅模式相比， Promise/Deferred模式的API接口和抽象模型都十分简洁。 \n    - 将业务中不可变的部分封装在了Deferred中， 将可变的部分交给了Promise\n    - Promise是高级接口， 事件是低级接口\n  - 2. Promise中的多异步协作\n    - Deferred.prototype.all\n  - 3. Promise的进阶知识\n    - Promise的秘诀其实在于对队列的操作\n    - 支持序列执行的Promise - `promise().then(obj.api1).then(obj.api2)`\n    - 将API Promise化\n- 3、流程控制库\n  - 1. 尾触发与Next\n    - 需要手工调用才能持续执行后续调用的， 我们将此类方法叫做尾触发， 常见的关键词是next。\n    - Connect的中间件应用\n  - 2. async\n    - 流程控制模块async\n    - series()串行、parallel()并行、waterfall()依赖处理、auto()自动依赖处理\n  - 3. Step\n    - Step用到了this关键字\n  - 4. [wind](https://github.com/JeffreyZhao/wind) \n    - 当时思路很新颖，已经有后来async 和 await的雏形了\n    - eval(Wind.compile(\"async\", function() {}));\n    - $await();\n    - Wind.Async.sleep(20);\n  - 5、其他[streamlinejs](https://github.com/Sage/streamlinejs)\n#### 4、异步并发控制\n> 解决并发量过大的问题\n- bagpipe的解决方案\n  - 主要通过一个队列来控制并发量\n  - bagpipe类似于打开了一道窗口，允许异步调用并行进行，但是严格限定上限。 \n  - 考虑拒绝模式（太多就不接受了）、超时控制\n- async的解决方案\n  - parallelLimit\n  - queue：动态地增加并行任务\n\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-3异步I/O","url":"/2024/03/06/Nodejs/3/","content":"#### 导论\n- 异步早就存在于操作系统的底层，在底层系统中， 异步通过信号量、 消息等方式有了广泛的应用\n- 在众多高级编程语言或运行平台中， 将异步作为主要编程方式和设计理念的， Node是首个\n\n#### 1、为什么要异步I/O\n> 更快地影响资源，响应时间Max(M,N)，前端体验更好\n> 更合理的利用后端的资源\n- 1、`用户体验`（前端），\n  - JavaScript在单线程上执行，与UI渲染共用一个线程\n  - 前端通过异步可以消除掉UI阻塞的现象\n  - 更快地响应资源，消除阻塞的影响，\n- 2、`资源分配`（后端）\n  - 单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。 \n  - 多线程编程模型也因为编程中的死锁、 状态同步等问题让开发人员头疼\n  - Node在两者之间给出了它的方案： \n    - 利用单线程， 远离多线程死锁、 状态同步等问题；\n    - 利用异步I/O， 让单线程远离阻塞，同时使用子进程，以更好地使用CPU。\n\n#### 2、异步I/O实现现状\n> 计算机内核层面如何I/O，阻塞和非阻塞，如何实现底层的异步高效查询\n- 实际效果而言，异步和非阻塞都达到了我们并行I/O的目的。 \n- 但是从计算机内核I/O而言， 异步/同步和阻塞/非阻塞实际上是两回事\n- 阻塞I/O vs 非阻塞I/O\n  - 阻塞I/O -> 等待\n  - 非阻塞I/O -> 立即返回 -> 是状态 -> 轮询来获取完整数据\n  - 轮询有很多种，最终采用epoll，但是依旧有问题，使用自定义线程池完成\n  - 技术发展\n    - linux\n      - Linux下效率最高epoll技术（事件通知、回调，不是遍历查询，不浪费cpu）\n      - 但是对于应用程序而言（应用程序在上层，不知道底层具体发生了什么，因为还是在等），它仍然只能算是一种同步\n      - epoll休眠期间CPU几乎是闲置的，等于说其他的底层调用，依旧需要等待\n      - 只需在I/O完成后通过信号或回调将数据传递给应用程序即可\n      - AIO 支持异步，但是有缺陷\n      - libeio(采用线程池与阻塞I/O模拟异步I/O) -> 最终：自定义线程池来完成异步I/O\n    - windows\n      - IOCP\n      - 内部其实仍然是线程池原理， 不同之处在于这些线程池由系统内核接手管理\n      - 与Node的异步模型十分接近\n  - js这一层是单线程，但是底层是多线程\n    - 相对而言，Node是单线程的， 这里的单线程是JavaScript执行在单线程中。\n    - 在Node中， 无论是*nix还是Windows平台， 内部完成I/O任务的另有线程池。\n\n#### 3、Node的异步I/O\n> Node的执行模型：事件循环、观察者和请求对象\n> \n> IOCP底层如何实现的思路\n- 事件循环\n  - 类似while(true)的循环 \n  - -> Tick(执行一次循环体) \n  - -> 查看是否有事件待处理\n  - -> 如果有，就取出事件及其相关的回调函数，并执行回调\n  - -> 进入下个循环，是否还有其他事件\n  - -> 如果没有，退出进程\n- 观察者\n  - 在每个Tick的过程中，是否有事件需要处理呢？\n  - 每个事件循环中有一个或者多个观察者， \n  - 而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件\n  - 循环 - 做菜\n  - 观察者 - 服务台小妹\n  - 客人点单 - 回调\n  - 收到下单 - 就是一个事件\n  - 事件循环 - 典型的生产者/消费者模型\n    - 异步I/O、 网络请求等则是事件的生产者， 源源不断为Node提供不同类型的事件， \n    - 这些事件被传递到对应的观察者那里， \n    - 事件循环则从观察者那里取出事件并处理\n- 请求对象\n  - IOCP实现\n  - 发出调用后， 到回调函数被执行， 中间发生了什么呢？请求对象\n  - js代码 -> fs.open() -> c++核心代码 -> 核心模块 -> 内建模块 -> libuv调用 ->\n  - uv_fs_open()调用过程中创建：FSReqWrap请求对象（js层的参数和当前方法都被封装在上边）\n  - 回调函数 -> 放在oncomplete_sym属性上 -> \n  - 调用QueueUserWorkItem()，将请求对象推入线程池等待执行\n    - 第一个参数：uv_fs_thread_pro，第二个参数：所需参数（请求对象）\n    - uv_fs_thread_proc()方法会根据传入参数的类型调用相应的底层函数。 以uv_fs_open()为例，实际上调用fs__open()方法。\n  - JavaScript调用立即返回， 由JavaScript层面发起的异步调用的第一阶段就此结束\n- 执行回调\n  - 线程池中的I/O操作调用完毕之后， \n  - 会将获取的结果储存在req>result属性上\n  - 调用PostQueuedCompletionStatus()通知IOCP， 告知当前对象操作已经完成\n  - PostQueuedCompletionStatus作用是向IOCP提交执行状态， 并将线程归还线程池\n  - 提交的状态， 可以通过GetQueuedCompletionStatus()提取\n  - 还动用了事件循环的I/O观察者\n    - 在每次Tick的执行中，\n    - 它会调用IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求\n    - 如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理\n    - I/O观察者回调函数的行为就是\n    - 取出请求对象的result属性作为参数，\n    - 取出oncomplete_sym属性作为方法， \n    - 然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。\n  ![](./img/3.3.1.png)\n\n#### 4、非I/O的异步API\n> 主讲setTimeout/setInterval/setImmediate/process.nextTick()区别\n\n- setTimeout/setInterval\n  - 实现原理与异步I/O比较类似， 只是不需要I/O线程池的参与\n  - 创建的定时器会被插入到定时器观察者内部的一个红黑树中\n  - 每次Tick执行时， 会从该红黑树中迭代取出定时器对象， 检查是否超过定时时间\n  - 如果超过，就形成一个事件，它的回调函数将立即执行\n  - setInterval是重复性的检测和执行\n  - 不足：\n    - 非精确，一次循环占用时间过多，产生阻塞，那么就会超时\n    - 定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能\n- process.nextTick()\n  - 优点：操作相对较为轻量\n  - 每次调用process.nextTick()方法，只会将回调函数放入队列中\n  - 定时器中采用红黑树的操作时间复杂度为O(lg(n))， nextTick()的时间复杂度为O(1)\n- setImmediate\n  - process.nextTick()优先级要高于setImmediate()\n  - 观察者顺序\n    - 在于事件循环对观察者的检查是有先后顺序的， \n    - process.nextTick()属于idle观察者， \n    - setImmediate()属于check观察者\n    - idle先于I/O,I/O先于check\n  - 存储类型\n    - process.nextTick()的回调函数保存在一个数组中， \n    - setImmediate()的结果则是保存在链表中\n\n#### 5、事件驱动与高性能服务器\n- Node\n  - 对于网络套接字的处理， Node也应用到了异步I/O， \n  - 网络套接字上侦听到的请求都会形成事件交给I/O观察者。 \n- Apache\n  - 每线程/每请求的方式目前还被Apache所采用\n- Nginx\n  - Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，\n  - 用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺\n- 其他平台\n  - 没有成功异步I/O\n  - 同步I/O库的存在，异步不是主流，及时实现也未必能流行起来\n  - 异步I/O实现，其主旨是使I/O操作与CPU操作分离\n  - Tim Caswell将Node的这套思想重新移植到了Lua平台， 该项目叫luavit。","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-2模块机制","url":"/2024/03/06/Nodejs/2/","content":"#### 1、CommonJS规范\n> 这一章中主要讲了\n> \n> CommonJS规范是如何产生的，后端没有规范\n> \n> 以及CommonJS规范中的模块规范 require、exprots、module.exports\n- 1、出现\n  - CommonJS规范提出是旨在解决JavaScript在非浏览器环境中的模块化问题。\n  - 先有CommonJS规范，node采用了CommonJS规范\n- 2、模块规范\n  - 引用\n    ```js\n    var math = require('math');\n    ```\n  - 导出\n    - module.exports \n    ```js\n      // ok\n      exports.add = function () {\n        var sum = 0,\n          i = 0,\n          args = arguments,\n          l = args.length;\n        while (i < l) {\n          sum += args[i++];\n        }\n        return sum;\n      };\n      // 报错\n      // exports只是module.exports的一个引用\n      // exports重新赋值时,改变了他的引用\n      // exports将不再指向module.exports，而是指向一个新的对象\n      exports = function(){\n        console.log(1)\n      }\n    ```\n    - exports\n      ```js\n       //ok\n        module.exports = {\n          add:function () {}\n        }\n        // ok\n        module.exports = function (){\n          console.log(1)\n        }\n      ```\n  - 标识\n    - 模块标识其实就是传递给require()方法的参数\n    - 将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖\n    - 导出和引入机制使得用户完全不必考虑变量污染\n    - 下个章节有详细讨论\n\n\n#### 2、node的模块实现\n> 这一章中主要讲了\n> \n> 比较细致的阐述：node如何加载模块\n- 加载不同的模块：核心模块、文件模块，都进行缓存\n- 文件模块\n  - 路径形式的文件模块：模块路径（多层级的node_modules）、文件定位（目录、扩展名、包）如何解析，不同情况的处理\n  - 自定义模块，查找最慢\n- 编译不同模块:(缓存Module._cache对象上)\n  - .js模块（头尾包装，包装在了一个方法内部，隔离作用域，全局变量从形参中获取）、\n  - .node模块（不需要编译、process.dlopen()加载执行）、\n  - .json模块（require加载）\n#### 3、核心模块\n> 本章主要介绍了\n> \n> 核心模块组成，以及两部分如何加载、编译\n> \n> 核心模块引入流程（从上到下），以及编写核心组件\n\n- 核心模块分两部分\n  - javascript编写的（Node项目lib目录），\n    - 先转存为c/c++代码，生成node_natives.h头文件\n    - 编译，编译成功（缓存到NativeModule._cache对象上）\n    - process.binding('natives')取出放置在NativeModule._source\n  - c/c++编写的（Node项目src目录）（内建模块），\n    - NODE_MODULE宏将模块定义到node命名空间中,\n    - node_extensions.h 将内建模块统一放进了一个叫node_module_list的数组中\n    - get_builtin_module()从node_module_list数组中取出\n    - 如何导出\n      - Node在启动时，全局变量process，提供Binding()方法来协助加载内建模块\n      - Binding方法：\n        - 先创建一个exports空对象，调用get_builtin_module()方法取出内建模块对象，\n        - 通过执行register_func()填充exports对象，\n        - 最后将exports对象按模块名缓存，并返回给调用方完成导出。\n\n- 核心模块引入流程\n  - require(\"os\") -> NativeModule.require(\"os\") -> process.binding(\"os\") -> get_builtin_module(\"node_os\") -> NODE_MODULE(node_os,reg_func)\n\n- 编写核心模块\n  - js文件\n  - 编写头文件和编写C/C++文件\n  - 还需要更改src/node_extensions.h，在NODE_EXT_LIST_END前添加NODE_EXT_LIST_ITEM(node_hello)\n  - 让编写的两份代码编译进执行文件，同时需要更改Node的项目生成文件node.gyp\n\n#### 4、c/c++扩展模块\n> 本章主讲：\n> \n> 1、c/c++扩展模块的编写、编译、加载等\n> \n> 2、目前只需了解一下整个的过程，等学习c++以后，可以再重新编写\n- 1、c/c++扩展模块的优势，比js更有性能的优势（位运算）\n- 2、原生模块编译：\n  - 在不同的平台(linux\\windows)，\n  - 也是用了node-gyp\n  - 底层的编译工具链，用不同的编译软件(g++/gcc、vc++)，\n  - 生成不同的文件(.so、.dll)，但都是.node\n- 3、c/c++扩展模块的\n  - 编写：.js、./hello/hello.cc(与内建模块有区别，没有node_module_list链表)\n  - 编译：GYP编译（跨平台）、node-gyp configure、node-gyp build、./build/Release/hello.node\n  - 加载：require、process.dlopen()、uv_dlopen()/uv_dlsym()(libuv库进行封装的)\n  - 优点：加载之后不需要编译、增强拓展\n\n\n#### 5、模块调用栈\n> 本章主讲：\n>\n> 模块之间的调用关系\n>\n> npm包\n- 模块之间的调用关系\n- ![](img/2.5.1.png)\n- 包\n  - 包结构\n  - 包描述文件package.json\n    - maintainers 维护者\n    - contributors 贡献者\n    - bugs bug反馈\n    - repositories 源代码\n    - homepage 当前包的网站地址\n    - bin 命令行工具\n- npm\n  - npm install -g name\n    - 全局模式这个称谓其实并不精确，存在诸多误导。 \n    - 实际上，-g是将一个包安装为全局可用的可执行命令\n  - npm adduser 注册\n  - npm owner 管理包的权限\n    - npm owner ls <package name>\n    - npm owner add <user> <package name>\n    - npm owner rm <user> <package name>\n  - npm ls分析包\n- 企业搭建自己的NPM仓库\n- 优良优秀的包\n  - 具备良好的测试。\n  - 具备良好的文档（README、 API） 。\n  - 具备良好的测试覆盖率。\n  - 具备良好的编码规范。\n  -更多条件。\n\n#### 6、前后端共用模块\n> 模块向前端的发展\n- 模块规范为了适用前端的场景，出现了异步模块定义\n- amd `define(id?, dependencies?, factory)`\n- cmd 与amd区别在于定义模块和依赖`引入`的部分\n- 当前这些都已经走进了历史，现在esmodule的天下了\n","tags":["server","Nodejs"]},{"title":"《深入浅出Node.js》-1简介","url":"/2024/03/06/Nodejs/1/","content":"\n#### 1、诞生\n- 2009年，Ryan Dahl 发布\n\n#### 2、由来及发展\n> 这一章主要讲了\n> node使用js作为实现语言的由来：js符合作者预期\n> 和node名字的由来：网络功能节点\n- 1、作者的初衷就是\n  - 设计一款基于事件驱动、非阻塞I/O的Web服务器，达到高性能\n  - 评估了C、Lua、Haskell、Ruby，都不理想\n  - js评估\n    - js 后端历史包袱为零 采用非阻塞I/O\n    - 浏览器广泛的事件驱动\n    - v8高性能引擎\n  - node而生，js成为其实现语言\n- 2、为什么叫node\n  - 最后发展超过了他最初单纯开发一个Web服务器的想法\n  - 变成了构建网络应用的一个基础框架\n  - 包含：服务器、客户端、命令行工具\n  - 最终：\n    - 为一个强制不共享任何资源的单线程、单进程系统，\n    - 包含十分适宜网络的库，\n    - 为构建大型分布式应用程序提供基础设施\n    - 成为一个构建快速、可伸缩的网络应用平台\n  - 通过通信协议来组织许多Node，\n  - 非常容易通过扩展来达成构建大型网络应用的目的\n  - 每一个Node进程都构成这个网络应用中的一个节点\n  - 因此叫node就符合了这个款产品的定位\n\n\n#### 3、node 意义\n> 这一章讲了node诞生产生意义\n> 主要是js以后可以再服务器端大展拳脚\n> js在浏览器端和服务器端做了对比\n- 浏览器中局限\n  - h5和js的能力\n  - 来于webkit 和 v8\n  - 取决于浏览器中间层提供的支持有多少\n  - 长久以来却限制在浏览器的沙箱中运行\n- Nodejs 与 浏览器 对比\n  - 都是基于事件驱动的异步架构\n  - 浏览器\n    - 通过事件驱动来服务界面上的交互\n  - Node\n    - 通过事件驱动来服务I/O\n    - 并且功能得到拓展：随心所欲地访问本地文件，可以搭建WebSocket服务器端，可以连接数据库\n  - Node不处理UI，但用与浏览器相同的机制和原理运行\n  - 也有对两者同时运用的尝试\n    - 出现node-webkit这样的项目（2012年）\n      - Node中的事件循环和WebKit的事件循环融合在一起，\n      - 既可以通过它享受HTML、CSS带来的UI构建，\n      - 也能通过它访问本地资源，将两者的优势整合到一起\n    - github未找到项目（2024年），可能已经过时\n    - 像后来的nuxt是对此一种延续（我的理解）\n![img](https://res.weread.qq.com/wrepub/epub_26211935_3)\n\n\n#### 4、Node特点\n> 本章讲了Node的特点\n> 异步I/O：读取文件等、事件机制驱动：模拟浏览器、回调函数\n> 单线程：优点以及不足，child_process解决不足\n> 扩平台：libuv解决\n- 特点1：异步I/O\n  - 以读取文件为例，我们可以看到它与前端Ajax调用的方式是极其类似的\n  ```js\n    var fs = require('fs');\n    fs.readFile('/path', function (err, file) {\n      console.log(’读取文件完成’)\n    });\n    console.log(’发起读取文件’);\n  ```\n  - 在Node中，绝大多数的操作都以异步的方式进行调用。\n  - Ryan Dahl排除万难，在底层构建了很多异步I/O的API：例如文件读取、网络请求等\n  - 从语言层面很自然地进行并行I/O操作\n- 特点2：事件\n  - 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。\n  - 为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件\n    ```js\n        var http = require('http');\n        // 侦听服务器的request事件\n        http.createServer(function (req, res) {\n          var postData = '';\n          req.setEncoding('utf8');\n          // 侦听请求的data事件\n          req.on('data', function (chunk) {\n            postData += chunk;\n          });\n          // 侦听请求的end事件\n          req.on('end', function () {\n            res.end(postData);\n          });\n        }).listen(8080);\n        console.log(’服务器启动完成’);\n    ```\n  - 事件编程特点：轻量级、松耦合、只关注事务点等优势\n  - 问题：事件与事件之间各自独立，如何协作是一个问题。\n- 特点3：回调函数\n  - 回调函数无处不在\n  - 回调函数也是最好的接受异步调用返回数据的方式。\n- 特点4：单线程\n  - Node保持了JavaScript在浏览器中单线程的特点\n  - 优点：\n    - 避免了多线程问题\n    - 多线程编程那样处处在意状态的同步问题\n    - 这里没有死锁的存在，\n    - 也没有线程上下文交换所带来的性能上的开销\n  - 不足：\n    - 无法利用多核CPU\n    - 错误会引起整个应用退出，应用的健壮性值得考验\n    - 大量计算占用CPU导致无法继续调用异步I/O\n  - 解决不足：\n    - Node采用了与Web Workers相同的思路\n    - 来解决单线程中大计算量的问题：child_process\n      - 从容地应对单线程在健壮性和无法利用多核CPU方面的问题。\n      - 将计算分发到各个子进程，\n      - 可以将大量计算分解掉，\n      - 然后再通过进程之间的事件消息来传递结果，\n      - 这可以很好地保持应用模型的简单和低依赖\n- 特点5：跨平台\n  - Node基于libuv实现跨平台的架构示意图\n  - 兼容Windows和*nix平台主要得益于Node在架构层面的改动\n  - 它在操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv。\n  - 目前，libuv已经成为许多系统实现跨平台的基础组件\n  - Node的第三方C++模块也可以借助libuv实现跨平台。\n  \n\n#### 5、应用场景\n> 本章主要讲了Node的使用场景，包括\n> I/O密集型\n> 如胜任CPU密集型业务：c++扩展、子进程\n> 遗留系统：使用老接口\n> 分布式数据库查询\n-  1、I/O密集型\n   -  Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源\n   -  主要在于Node利用事件循环的处理能力\n-  2、CPU密集型业务\n   -  收否胜任？\n   -  V8的执行效率非常高，和其他语言相比速度也非常快\n   -  主要挑战是：js单线程，如果长时间运行计算，使得后续I/O无法发起\n   -  解决方法：\n      -  调整、分解大型运算任务为多个小任务，\n      -  运算适时释放，\n      -  不阻塞I/O调用发起\n      -  对于一个纯计算的场景，或许根本没有I/O，改用多线程\n      -  Node没有多线程，如何解决？\n         -  Node可以通过编写C/C++扩展的方式更高效地利用CPU\n         -  子进程处理\n      -  CPU密集不可怕，如何合理调度是诀窍\n-  3、遗留系统处理\n   -  对待原来的旧系统，譬如java/jsp\n   -  旧有的系统具有非常稳定的数据输出，持续为传统网站服务，\n   -  同时为移动版提供数据源，Node将该数据源当做数据接口，发挥异步并行的优势\n   -  旧系统只做接口和中间件\n-  4、分布式应用\n   -  并行地去多台数据库中获取数据并合并\n   -  NodeFox能实现对多台MySQL数据库的查询，如同查询一台MySQL一样，\n   -  而ITier更强大，查询多个数据库（不同的数据库）如同查询单个数据库一样\n   -  Node高效利用并行I/O的过程，也是高效使用数据库的过程\n\n\n\n\n#### 总结\n- 第一篇讲的是一些概念，但是非常重要，例如异步、事件（事件驱动）、回调、非阻塞、I/O、libuv等\n- 之前java同事问我，node到底是个啥？我其实都没有答好，在他们看来是服务器应该像阿帕奇之类的，怎么还用js做开发呢，现在理解node其实是一个综合体，既包括服务器，也包括运行时的环境，使用v8\n- [《深入浅出Node.js》代码地址](https://github.com/JacksonTian/diveintonode_examples)\n","tags":["server","Nodejs"]}]